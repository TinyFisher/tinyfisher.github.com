
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tinyfisher blog</title>
    <meta name="author" content="tinyfisher">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- <link href="http://lib.sinaapp.com/js/bootstrap/latest/css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all"> -->
    <link href="http://lib.sinaapp.com/js/bootstrap/2.0.3/css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/google-code-prettify/prettify.css" rel="stylesheet" type="text/css" media="all">
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <!-- <script type="text/javascript" src="http://lib.sinaapp.com/js/bootstrap/latest/js/bootstrap.min.js"></script> -->
    <script type="text/javascript" src="http://lib.sinaapp.com/js/bootstrap/2.0.3/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/themes/twitter/google-code-prettify/prettify.js"></script>
    <script type="text/javascript" src="/assets/themes/twitter/js/application.js"></script>
  </head>

  <body data-spy="scroll" data-target=".subnav" data-offset="100">

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">tinyfisher blog</a>
          <div class="nav-collapse">
            <ul class="nav">


              <li><a href="/archive.html">归档</a></li>
              <li><a href="/categories.html">目录</a></li>
              <li><a href="/pages.html">页面</a></li>
              <li><a href="/tags.html">标签</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        


<div class="row">
  <div class="span12">
    


<div class="subnav page-launcher">
  <ul class="nav nav-pills">
    <li><a href="#blog20131216sina" title="新浪实习">新浪实习</a></li>
    <li><a href="#blog20131015zqlt" title="一道有趣的面试题">一道有趣的面试题</a></li>
    <li><a href="#algorithm20131014interview" title="面试算法题整理">面试算法题整理</a></li>
    <li><a href="#blog20130926alibaba2" title="阿里巴巴二面总结">阿里巴巴二面总结</a></li>
    <li><a href="#blog20130924factory" title="创新工场一面总结">创新工场一面总结</a></li>
  </ul>
</div>


<div class="row">
  <div class="span8">
  
  
  <section id="blog20131216sina">
    <article>
      <header>
      <h1><a href="/blog/2013/12/16/sina">新浪实习</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-12-16</span></div>
    </header>
    <div class="content"><p>今天第一天去新浪实习，吐槽下实验室，一直不让实习，太黑。最近比较闲，没啥面试，论文也差不多了，终于找到了人生第一份实习，也算是和北京告别的第一天。当年怀着无比向往的心情来到帝都，时间真快，一转眼就要离开了，从一开始不适应这里干燥的空气，鼻子出血，到现在已经习惯了这里的气侯，甚至雾霾，真要离开竟有一丝不舍，因为这里是北京，有着五彩斑阑的机会和无限的可能，有着无数年轻人的梦想。告别帝都从新浪实习开始吧。第一天，人工查看是否是垃圾邮件，编写python脚本自动发邮件进行测试，代码如下</p>

<pre><code>import smtplib
from email.mime.text import MIMEText
mailto_list=[&quot;yxh.8116836@163.com&quot;,&quot;tinyfisher@foxmail.com&quot;] 
mail_host=&quot;smtp.sina.cn&quot;   
mail_user=&quot;tinyfisherbupt&quot; 
mail_pass=&quot;yxh19890804&quot;    
mail_postfix=&quot;sina.com&quot;    
def send_mail(to_list,sub,content):    
    me=mail_user+&quot;&lt;&quot;+mail_user+&quot;@&quot;+mail_postfix+&quot;&gt;&quot;
    msg = MIMEText(content)
    msg[&#39;Subject&#39;] = sub
    msg[&#39;From&#39;] = me
    msg[&#39;To&#39;] = &quot;;&quot;.join(to_list)
    try:
        s = smtplib.SMTP()
        s.connect(mail_host)
        s.login(mail_user,mail_pass) 
        s.sendmail(me, to_list, msg.as_string())
        s.close()
        return True
        except Exception, e:
        print str(e)
        return False
if __name__ == &#39;__main__&#39;:
    if send_mail(mailto_list,&quot;subject&quot;,&quot;content&quot;):
        print &quot;send success&quot;
    else:
        print &quot;send fail&quot;</code></pre></div>
    </article>
  </section>
  
  
  <section id="blog20131015zqlt">
    <article>
      <header>
      <h1><a href="/blog/2013/10/15/zqlt">一道有趣的面试题</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-10-15</span></div>
    </header>
    <div class="content"><h4 id='60910120131'>题目：给你两个骰子，每个骰子的6个面都是空的，现在要你把0~9这10个数填到这两个骰子的12个空白面上（数字可以重复），使得能够用这两个骰子表示一个月的号数：从01到31（出自中清龙图）</h4>

<p><strong>提示：这两个骰子中的数既可以表示十位，又可以表示个位</strong></p>

<p><strong>思路：1.那就先看从01到09怎么填吧</strong></p>

<p>例如两个骰子A,B；我首先在A中填0，在B中填1,2,3,4,5 此时，按照AB的摆放，可以表示01到05，我再在B中填0，A中填6,7,8,9，此时按照BA的摆放，可以表示06到09，这时A六个面：0,6,7,8,9，空；B中六个面：1,2,3,4,5,0<br />此时A中还剩一个空位，B已经满。</p>

<p><strong>2.再来看10~19怎么填</strong><br />因为B中有1，按照BA的摆放，可以表示10,16,17,18,19；要表示其他的必须在A中存放1，此时A：0,6,7,8,9,1；按照AB摆放，可以表示：11,12,13,14,15,10；<br />此时A，B都满了，其中A:0,6,7,8,9,1；B：1,2,3,4,5,0；<br /><strong>3.再看20~29：</strong><br />因为B中有2，按照BA摆放，可以表示：20,26,27,28,29,21；<strong>可A中已经满了，怎么表示其他的数呢？</strong><br /><strong>面试官提示：如果A有7个面，你怎么做？</strong><br />如果A有7个面，那我按照上面的思路，在A中再填2，此时A:0,6,7,8,9,1,2；按照AB的摆放可以表示20,21,22,23,24,25；至于30,31是没有问题的。<br /><strong>现在的问题就是：2个骰子12个面，如果13个面，问题解决，但少了一个面，能否将某些数字压缩？</strong></p>

<p><strong>面试官提示：首先看看那些数字是必须存在于两个骰子？看看0,1,2是否必须存在？</strong></p>

<p>首先1和2肯定存在，因为要表示11和22,0也是必须存在，若只有一个面有0，肯定不能表示01到09；<br />ok，此时A:0,1,2；B:0,1,2；那么还剩下6个面和7个数：3,4,5,6,7,8,9，<strong>现在的问题是：怎么把这7个数压缩成六个？</strong><br />我：“这不可能吧？”<br />面试官：“我给你的是骰子，不是数组，想想有没有其他方法？”<br />我：“我用刀切一个骰子，变成13个面”（囧）<br />面试官：“我可没给你刀，骰子可以随意摆，再想想？”<br />我：“难道是6跟9算一个？”<br />面试官：“嗯，不错，想的还挺快。”</p>

<p>有点脑经急转弯的意思，面试官后来说了他为什么出这道题：<strong>程序员在编代码的时候，可能会陷入思维定式，有时候我们的空间和时间有限，必须要提高程序的效率，还有就是代码的重用，6跟9倒一下就可以，代码中可重用的有很多，需要注意。</strong></p>

<p>总的来说，这道题还是非常有趣的，面试官是北邮师兄，通过一步步的沟通提示，完成这道题，感觉还是不错的，哈哈~</p></div>
    </article>
  </section>
  
  
  <section id="algorithm20131014interview">
    <article>
      <header>
      <h1><a href="/algorithm/2013/10/14/interview">面试算法题整理</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-10-14</span></div>
    </header>
    <div class="content"><p>最近面试跪了不少，都基本是跪在算法题上，现在把遇到的一些题目记录下来，方面以后复习</p>

<h4 id='10111001111000001100000014041'>1.一个字符串只有0和1，如“110011110000”，找到这个串中的最长子串，使得子串的0和1个数相等，比如：1000<code>01011100</code>0001，阴影的部分有4个0、4个1（出自美团）</h4>

<p>思路：最简单的想法就是遍历所有的子串，之后判断该子串是否满足条件N^2子串，每个子串扫一遍判断0、1是否出现的次数相等，复杂度为O(N^3)，稍加思考就会发现， <strong>如果一个长度为n的子串满足条件，加么这n个元素的和加起来一定=(n/2)</strong>，这样在循环的过程中，增量加就可以了，不需要每个子串从头计算，复杂度降为O(N^2);伪码：</p>

<pre><code>int maxlen = 0, sum = 0, currlen = 0;
for(int i = 0; i &lt; N; ++i)
{
    sum = 0;
    for(int j = i; j &lt; N; ++j)
    {
        currlen = j - i + 1;
        sum += int(A[j]);
        if(currlen%2 == 0 &amp;&amp; sum == currlen/2 &amp;&amp; currlen &gt; maxlen)
            maxlen = currlen;
	}
}</code></pre>

<p>还有没有办法进一步降低算法的复杂度呢？</p>

<p>面试官说有这样一种巧妙的解法：定义一个数据B<span>N</span>， B<span>i</span>表示从A<span>0&#8230;i</span>中 num_of_0 - num_of_1，0的个数与1的个数的差，那么如果A<span>i</span> ~ A<span>j</span>（A<span>i</span>,A<span>j</span>选一个包含）是符合条件的子串，一定有 B<span>i</span> == B<span>j</span>，因为中间的部分0、1个数相等，相减等于0。 只需要扫一遍A<span>N</span>就能把B<span>N</span>构造出来了。<strong>这样问题就转换成了求距离最远的一对数</strong>，使得B<span>i</span> == B<span>j</span>，因为B<span>i</span>的范围一定是<span>-N,N</span>，-N到N的范围都存起来，建一个-N到N的hash表，index就是-N到N，value就是index相等的两个数的最长距离，这样每扫到B<span>i</span>，如果hash表里的值还不存在，填i，若已经存在，填i和里面值得差，即为当前长度，需要更新最大长度这个值。其实代码真的非常简单，一个循环就搞定了，这就是算法和思考的乐趣:)</p>

<pre><code>int A[N],B[N];
int num[2*N + 1];
int count[2] = {0,0}, maxlen = 0, currlen = 0;
memset(C, 2*N, -1);
for(int i = 0; i &lt; N; ++i)
{
   count[ int(A[i]) ] += 1;
   B[i] = count[1] - count[0];
   if( num[ B[i] + N ] == -1)//尚不存在，B的下标是差，值是A的下标 
       num[ B[i] + N ] = i; 
   else//already exist
   {
       currlen = i - num[ B[i] + N ] + 1; //num[ B[i] + N ]是B[i]已存在的下标
       if(currlen &gt; maxlen)
           maxlen = currlen;
   }
}</code></pre>

<h4 id='2a1b2c4abbcccc'>2.编程实现把一个字符串从“a1b2c4”转成“abbcccc”，不准申请新的内存，原字符串可以认为后面的空间足够大（出自美团）</h4>

<p><strong>思路</strong>：统计所有的数字之和何以得到最终字符串的长度，然后利用两个指针str1指向原字符串尾，str2指向新字符串尾，记录str1的数字n，和前面的字符m，str2从后向前写n个m，直到str1指向第一个字符。</p>

<p><strong>问题</strong>：可能会出现覆盖问题，例如“a1b2c3”转成“abbccc”，原字符串和新字符串长度都是6，按照我上面的算法，第一步之后字符串会变成“a1bccc”，这是我无法得到b的次数2，因为2被c覆盖了。</p>

<p><strong>为什么会覆盖？</strong><br />原因在“a1”上，“a1”最后要变成“a”，原字符串多占了一位，导致后面的出现覆盖，所以对于所有的“X1”要进行预处理。</p>

<p><strong>怎么处理</strong>？<br />遍历一遍字符串，每遇到“1”，把后面的字符串向前移动一位，例如“a1b2c3”变成“ab2c3”，这个时候，再对“ab2c3”进行我之前的处理，第一步变成“ab2ccc”，是没有问题的。</p>

<p><strong>注意</strong>：因为把1去掉之后，原字符串的格式发生了变化，遍历的时候需要注意判断一下。</p>

<h4 id='33333123111'>3.整数分割，比如给定一整数3，其有如下情况：3=3,3=1+2,3=1+1+1,求一个数的所有分割组合（出自创新工场行云）</h4>

<p>n=m1+m2+&#8230;+mi; （其中mi为正整数，并且1 &lt;= mi &lt;= n），则{m1,m2,&#8230;,mi}为n的一个划分。</p>

<p>如果{m1,m2,&#8230;,mi}中的最大值不超过m，即max(m1,m2,&#8230;,mi)&lt;=m，则称它属于n的一个m划分。这里我们记n的m划分的个数为f(n,m);</p>

<p>例如n=4时，他有5个划分，{4},{3,1},{2,2},{2,1,1},{1,1,1,1};</p>

<p>该问题是求出n的所有划分个数，即f(n, n)。下面我们考虑求f(n,m)的方法;<br />根据n和m的关系，考虑以下几种情况：</p>

<p>(1) 当n=1时，不论m的值为多少（m&gt;0)，只有一种划分即{1};</p>

<p>(2) 当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,&#8230;,1};</p>

<p>(3) 当n=m时，根据划分中是否包含n，可以分为两种情况：</p>

<p>(a).划分中包含n的情况，只有一个即{n}；</p>

<p>(b).划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。</p>

<p>因此 当n=m时，f(n,n) =1 + f(n,n-1);</p>

<p>(4) 当n &lt; m时，由于划分中不可能出现负数，因此就相当于f(n,n);</p>

<p>(5) 当n &gt; m时，根据划分中是否包含最大值m，可以分为两种情况：</p>

<p>(a).划分中包含m的情况，即{m, {x1,x2,&#8230;xi}}, 其中{x1,x2,&#8230; xi} 的和为n-m，因此这种情况下为f(n-m,m)</p>

<p>(b).划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);</p>

<p>因此，当n &gt; m时 f(n, m) = f(n-m, m)+f(n,m-1);</p>

<p>综上：</p>

<pre><code>f(n,m)=1;(n=1||m=1)  

f(n,m)=f(n,n);(n&lt;m)  

f(n,m)=1+ f(n, m-1);(n=m)  

f(n,m)=f(n-m,m)+f(n,m-1); (n&gt;m)  </code></pre></div>
    </article>
  </section>
  
  
  <section id="blog20130926alibaba2">
    <article>
      <header>
      <h1><a href="/blog/2013/09/26/alibaba2">阿里巴巴二面总结</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-26</span></div>
    </header>
    <div class="content"><p>二面面试官澄观，一看就很牛逼的样子，年龄也比一面的易统大一些，拿着我的简历，顺手拿了几个零食把我带到大厅，开始面试<br /><strong>1.你擅长什么？</strong><br />我去，突出一个防不胜防，没有自我介绍，也不问项目，简历扫了一眼，扔一边。<br />这个问题不好答，我怕给自己挖一个坑，我就说linux用的还行，他说哪方面，我说系统使用方面，常用命令比较熟，他就问了一个问题，把一个文件夹里的.cpp文件中的BUPT换成alibaba，怎么实现？<br />sed -i &#8220;s/BUPT/alibaba/g&#8221; ./*.cpp</p>

<p>个人感觉这个问题就是坑啊，如果不是特别擅长，很容易被问住，好比让你在简历上选填你精通什么，然后问到你挂。<br /><strong>2.学生期间有什么可以展示的，不限技术</strong><br />随意发挥</p>

<p><strong>3.有用过多线程或者多进程么？在什么情况下用的？两者有什么区别</strong><br />项目中有个监听线程，监听到3G网卡掉线，自动重连。<br />多线程好处：节约资源，并发快<br />多进程好处：安全，即使子进程挂了，父进程不会挂 <br />多线程缺点：不安全，一个线程挂掉，整个进程挂了<br />多进程缺点：资源占用比较多，并发性不如线程</p>

<p><strong>4.apache知道吗？看过源码吗？是多进程还是多线程的？http请求方法有哪些？服务器怎么知道用户登陆过？</strong><br />知道，没看过，猜测是多进程的，GET，POST，（其余不常用，没怎么记，面试官貌似不满意）。<br />通过sessionid，用户请求时，服务器生成一个sessionid传给客户端，客户端用cookie保存sessionid，然后登陆的时候通过cookie把sessionid再发送给服务端。（大致这个意思，面试官大致满意）</p>

<p><strong>5.二叉树求深度，不准递归，树是只读的</strong><br />我的思路：用队列按层遍历，每一层加一，面试官说：你怎么知道这一层遍历完了？这里想了很久，说再用一个栈保存结果，栈为空的时候，这层完了，此时加一，面试官说：行是行，但浪费空间。</p>

<p><strong>6.求一千亿个数的中位数，这些数无序</strong><br />我的思路：hash%1000，分成小文件，求出小文件的最大和最小值，然后按照这个区间，使得这1000个小文件按照顺序排列，中位数在中间的小文件里，面试官说：不一定。发现是的，我说那我记录每个文件的个数，根据这个元素个数定位到小文件，对这个小文件排序，根据偏移量，找到中位数，面试官说对。</p>

<p><strong>总结：深入再深入，必须能有一样能征服面试官的，要有亮点，这点我还得加强，本来想说项目，直接被无视。算法题注定是难的，千万别放弃，展示出想要解决他的勇气，可以问面试官要提示，互动的解决这个问题，一旦放弃，这轮面试也就挂了。</strong></p>

<p><strong>附：http请求方式</strong></p>

<p>GET,HEAD,PUT,DELETE,POST,OPTIONS</p>

<p>但其实我们大部分情况下只用到了GET和POST。如果想设计一个符合RESTful规范的web应用程序，则这六种方法都会用到。不过即使暂时不想涉及REST，了解这六种方法的本质仍然是很有作用的。大家将会发现，原来web也是很简洁明了的。下面依次说明这六种方法。</p>

<p>GET：GET可以说是最常见的了，它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，没有body</p>

<p>HEAD：HEAD和GET本质是一样的，但只请求页面的头部。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p>

<p>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，<strong>PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</strong>举个例子：如一个用于提交博文的URL，/addBlog。如果用PUT，则提交的URL会是像这样的”/addBlog/abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。目前大部分博客都是这样的。显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。</p>

<p>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p>

<p>POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。</p>

<p>OPTIONS：这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p>

<p>其实还有一个TRACE方法，不过这个基本上不会用到，这里就不介绍了。以上的六种方法，我们可以跟数据库的CRUD增删改查操作对应起来：</p>

<p>CREATE ：PUT</p>

<p>READ：GET</p>

<p>UPDATE：POST</p>

<p>DELETE：DELETE</p>

<p><strong>关于session和cookie</strong></p>

<p>为什么会有cookie和session呢,大家都知道，http是无状态的协议（<strong>无状态是指，当浏览器发送请求给服务器的时候，服务器响应，但是同一个浏览器再发送请求给服务器的时候，他会响应，但是他不知道你就是刚才那个浏览器，简单地说，就是服务器不会去记得你，所以是无状态协议。</strong>），客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能实现网上商店中的购物车呢？</p>

<p>session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现，系统会创造一个名为JSESSIONID的输出cookie，我们叫做session cookie,以区别persistent cookies,也就是我们通常所说的cookie,注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，这也就是我们刚才看到的JSESSIONID，我们通常情是看不到JSESSIONID的，但是当我们把浏览器的cookie禁止后，WEB服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到sessionid=KWJHUG6JJM65HS2K6之类的字符串。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把sessionid传递回服务器。</p>

<p>Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从：<span>系统盘</span>:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p>

<p><strong>关于二叉树求深度</strong></p>

<p>思路：先层次遍历一遍找出最后一个节点，然后目的变为求这个节点的深度。然后我们用循环一层一层找到它的上一层，找到一次，深度加1，最终可以得到二叉树的深度。不需要栈了。<br />例如下面的树：<br /><img alt='hello' src='/assets/themes/images/btree.jpg' /> <br />首先按层遍历获得最后一个元素J，然后从根再次按层遍历找到他的父节点E，此时深度+1，再从头按层遍历找到E的父节点B，此时深度加1，直到根节点为止</p>

<p><strong>关于1000亿个数的中位数</strong></p>

<p>我的那种hash%1000的分割法有点问题，因为整数是有范围的，可按照整数范围分割文件，这样就不需要对每个文件排序，然后根据index偏移量找到小文件，只需对这个文件进行排序，取偏移量的数即可</p>

<p>　　</p></div>
    </article>
  </section>
  
  
  <section id="blog20130924factory">
    <article>
      <header>
      <h1><a href="/blog/2013/09/24/factory">创新工场一面总结</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-24</span></div>
    </header>
    <div class="content"><p>跟hr约好了9点去面试，早上7点半起来，觉得不出意外能赶到，结果堵车了，急得要死，还好邮件里有hr的联系方式，提前打个电话说明了情况，对方表示没有关系，这下放心了。到了创新工场是大概9:10，迟到了10分钟左右，然后被hr mm带到一个叫手舞的玻璃房里，里面坐着面试官gg，谈吐穿着都非常儒雅，气氛不算很紧张。<br />首先自我介绍，然后挑一个项目介绍，扯了扯，面试官开始直奔主题，写代码，早闻创新工场的面试就是这个样子，开始进入正题：<br /><strong>1.快排，时间复杂度，怎么避免最坏情况的出现</strong></p>

<p>砍瓜切菜，至于优化在《算法导论》中看到过，partition的时候不是固定取末尾一个数，而是随机取，甚至可以随机取3个数，取这3个数的中位数作为key。面试官比较满意。</p>

<p><strong>2.一个整型无序数组，要求从中取三个数，要求：这三个数值递增，三个数在原数组中的下标值也递增，说思路</strong><br />这题时间不够，没想出来。我的思路是：<br />1.既然无序，那我排序试试看，结果发现如果排序势必会打乱下标的顺序，跟没排序其实没区别<br />2.那么既然下标已经有序了，我就把所有符合下标递增的三元组找出来，看他们的值是否递增，面试官说：这个肯定可以，有没有优化的办法？<br />卡住了，实在想不出来了，时间也到了，后来我就问面试官，这题怎么做，他告诉了我答案：<br />举个例子：2,1,4,3,5<br />面试官说我们只需要找到总共有多少个三元组，而不需要把他们找出来，充分利用数组下标已递增的特点，固定一个数，比如说4，那么以4为中值的三元组只需要从左边找到比4小的和右边找到比4大的即可。 哎，充分感觉智商不够用。不知道还能不能进二面</p>

<p><strong>总结：基础要牢，排序神马的基本是送分题，但也要深入研究下各个排序的特点，时间复杂度，最差情况，优化等等；至于算法题，还是搞题海战术吧，我这种智商的实在想不出来</strong><br />今天收到二面通知，开心！</p></div>
    </article>
  </section>
  
  <div class="pagination">
      <ul>
        <li><a href="/archive.html">归档</a></li>
        <li class="prev"><a href='/page2'>下一页 &rarr;</a></li>
      </ul>
  </div>
  </div>

  <aside class="span4">

    <section>
    <h4>最近发表</h4>
    <ul id="recent_posts">
      <li class="post">
        <a href="/blog/2013/12/16/sina">新浪实习</a>
      </li>
      <li class="post">
        <a href="/blog/2013/10/15/zqlt">一道有趣的面试题</a>
      </li>
      <li class="post">
        <a href="/algorithm/2013/10/14/interview">面试算法题整理</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/26/alibaba2">阿里巴巴二面总结</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/24/factory">创新工场一面总结</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/22/ibm">IBM Linux组电面总结</a>
      </li>
      <li class="post">
        <a href="/linux/2013/09/21/mongodb-mmp">Mongodb学习整理之内存映射机制</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/21/icap">ICAP RFC3507 部分章节翻译</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/20/alibaba">阿里巴巴面试总结</a>
      </li>
      <li class="post">
        <a href="/linux/2013/07/15/mongodb-install">Mongodb 学习整理之安装</a>
      </li>
    </ul>
    </section>
    
  
    <h4>分类</h4>
    <ul class="tag_box">
      
      


  
     
    	<li><a href="/categories.html#blog-ref">
    		blog <span>9</span>
    	</a></li>
     
    	<li><a href="/categories.html#algorithm-ref">
    		algorithm <span>9</span>
    	</a></li>
     
    	<li><a href="/categories.html#link-ref">
    		link <span>2</span>
    	</a></li>
     
    	<li><a href="/categories.html#btree-ref">
    		btree <span>3</span>
    	</a></li>
     
    	<li><a href="/categories.html#vim-ref">
    		vim <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#linux-ref">
    		linux <span>11</span>
    	</a></li>
     
    	<li><a href="/categories.html#c-ref">
    		c <span>2</span>
    	</a></li>
    
  


    </ul>
  

  </aside>
</div>

  </div>
</div>


      </div>

      <footer>
        <p>&copy; tinyfisher 2013 
          基于 <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          和 <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a> 构建
        </p>
      </footer>

    </div> <!-- /container -->
    
  </body>
</html>

