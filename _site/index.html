
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tinyfisher blog</title>
    <meta name="author" content="tinyfisher">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- <link href="http://lib.sinaapp.com/js/bootstrap/latest/css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all"> -->
    <link href="http://lib.sinaapp.com/js/bootstrap/2.0.3/css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/google-code-prettify/prettify.css" rel="stylesheet" type="text/css" media="all">
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <!-- <script type="text/javascript" src="http://lib.sinaapp.com/js/bootstrap/latest/js/bootstrap.min.js"></script> -->
    <script type="text/javascript" src="http://lib.sinaapp.com/js/bootstrap/2.0.3/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/themes/twitter/google-code-prettify/prettify.js"></script>
    <script type="text/javascript" src="/assets/themes/twitter/js/application.js"></script>
  </head>

  <body data-spy="scroll" data-target=".subnav" data-offset="100">

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">tinyfisher blog</a>
          <div class="nav-collapse">
            <ul class="nav">


              <li><a href="/archive.html">归档</a></li>
              <li><a href="/categories.html">目录</a></li>
              <li><a href="/pages.html">页面</a></li>
              <li><a href="/tags.html">标签</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        


<div class="row">
  <div class="span12">
    


<div class="subnav page-launcher">
  <ul class="nav nav-pills">
    <li><a href="#blog20130924factory" title="创新工场一面总结">创新工场一面总结</a></li>
    <li><a href="#blog20130922ibm" title="IBM Linux组电面总结">IBM Linux组电面总结...</a></li>
    <li><a href="#linux20130921mongodb-mmp" title="Mongodb学习整理之内存映射机制">Mongodb学习整理之内存映射机制</a></li>
    <li><a href="#blog20130921icap" title="ICAP RFC3507 部分章节翻译">ICAP RFC3507...</a></li>
    <li><a href="#linux20130715mongodb-install" title="Mongodb 学习整理之安装">Mongodb 学习整理之安装...</a></li>
  </ul>
</div>


<div class="row">
  <div class="span8">
  
  
  <section id="blog20130924factory">
    <article>
      <header>
      <h1><a href="/blog/2013/09/24/factory">创新工场一面总结</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-24</span></div>
    </header>
    <div class="content"><p>跟hr约好了9点去面试，早上7点半起来，觉得不出意外能赶到，结果堵车了，急得要死，还好邮件里有hr的联系方式，提前打个电话说明了情况，对方表示没有关系，这下放心了。到了创新工场是大概9:10，迟到了10分钟左右，然后被hr mm带到一个叫手舞的玻璃房里，里面坐着面试官gg，谈吐穿着都非常儒雅，气氛不算很紧张。<br />首先自我介绍，然后挑一个项目介绍，扯了扯，面试官开始直奔主题，写代码，早闻创新工场的面试就是这个样子，开始进入正题：<br /><strong>1.快排，时间复杂度，怎么避免最坏情况的出现</strong></p>

<p>砍瓜切菜，至于优化在《算法导论》中看到过，partition的时候不是固定取末尾一个数，而是随机取，甚至可以随机取3个数，取这3个数的中位数作为key。面试官比较满意。</p>

<p><strong>2.一个整型无序数组，要求从中取三个数，要求：这三个数值递增，三个数在原数组中的下标值也递增，说思路</strong><br />这题时间不够，没想出来。我的思路是：<br />1.既然无序，那我排序试试看，结果发现如果排序势必会打乱下标的顺序，跟没排序其实没区别<br />2.那么既然下标已经有序了，我就把所有符合下标递增的三元组找出来，看他们的值是否递增，面试官说：这个肯定可以，有没有优化的办法？<br />卡住了，实在想不出来了，时间也到了，后来我就问面试官，这题怎么做，他告诉了我答案：<br />举个例子：2,1,4,3,5<br />面试官说我们只需要找到总共有多少个三元组，而不需要把他们找出来，充分利用数组下标已递增的特点，固定一个数，比如说4，那么以4为中值的三元组只需要从左边找到比4小的和右边找到比4大的即可。 哎，充分感觉智商不够用。不知道还能不能进二面</p>

<p><strong>总结：基础要牢，排序神马的基本是送分题，但也要深入研究下各个排序的特点，时间复杂度，最差情况，优化等等；至于算法题，还是搞题海战术吧，我这种智商的实在想不出来</strong><br />今天收到二面通知，开心！</p></div>
    </article>
  </section>
  
  
  <section id="blog20130922ibm">
    <article>
      <header>
      <h1><a href="/blog/2013/09/22/ibm">IBM Linux组电面总结</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-22</span></div>
    </header>
    <div class="content"><p>下午四点多的突然接到IBM Linux电面，找了个安静的地方开始面试，对面GG比较友好，首先自我介绍，然后说了说项目，面试官还是很互动的，氛围比较轻松，还介绍了Linux组主要是做社区这一块，内核神马的。之后开始技术问题狂轰滥炸：</p>

<h4 id='1'><strong>1.大小端问题</strong></h4>

<p>这个才看过，总结下：小端是指低地址在低字节，正常比较容易理解的就是小端；大端是指高位在低字节，低位在高字节（比较绕）。。。<br />举个例子：0x1234，如果是小端，假设左边是内存高位，右边是内存低位，则小端存储如下：0x12,0x34；反之大端则是：0x34，0x12</p>

<h4 id='2fork'><strong>2.fork特点</strong></h4>

<p>这个回答的还不错，fork会有两个返回值，返回值为0的为子进程，返回值不为0的为父进程，其数值含义是子进程的pid</p>

<h4 id='3'><strong>3.僵尸进程</strong></h4>

<p>这个答错了，面试官问“是这样吗”之后，我就知道答错了，记混淆了。<br /><strong>我的错误回答：父进程比子进程先结束，子进程由init进程管理，子进程成为僵尸进程</strong><br />错误原因：我混淆了孤儿进程和僵尸进程的概念，我说的其实是孤儿进程。那么什么是僵尸进程呢？</p>

<p><strong>关于僵尸进程</strong><br /><strong>1.僵尸进程是怎么产生的？</strong></p>

<p>由于子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束. 那么会不会因为父进程太忙来不及wait子进程,或者说不知道子进程什么时候结束,而丢失子进程结束时的状态信息呢? 不会。因为UNIX提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是: <strong>在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放</strong>. 但这样就导致了问题,如果进程不调用wait / waitpid的话, 那么保留的那段信息就不会释放,其进程号就会一直被占用,但是系统所能使用的进程号是有限的,如果大量的产生僵死进程,将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害,应当避免。<br /><strong>总结一下：一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就变成僵尸进程。</strong></p>

<p><strong>2.僵尸进程的处理</strong><br />任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为<strong>僵尸进程(Zombie)的数据结构</strong>，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>

<h4 id='4git'>4.git</h4>

<p>面试关看我的博客是在github上写的，于是又问了我git的问题，git rebase是干什么用的？<br />我知道git add，commit，push，pull，checkout，reset，还真没用过rebase。。。</p>

<p><strong>首先回顾一下git基本命令</strong><br />git init 初始化代码仓库<br />git add file 将工作目录里的file文件修改提交到本地暂存区<br />git commit -m “commit” 将暂存区里的文件提交，备注“commit”，同时生成快照，就是一个hash值<br />git checkout file 把file回滚到修改前的状态，注意这个针对还没有提交到本地暂存区的文件，即git add之前的文件 git reset HEAD file 把file从暂存区撤离，即git add 的反操作<br />git revert &lt;$id&gt; 返回到commit id为&lt;$id&gt;的状态，本次也是一个动作，需要commit<br />git reset &#8211;hard HEAD~1 彻底回到倒数第二个commit，倒数第一个的commit会消失，文件内容也回到上个版本 git reset &#8211;soft HEAD~1 将最后一个commit撤销，但文件内容没变，只需要重新commit即可 git diff 查看本地文件和暂存区文件差别 git log 查看commit记录<br />git status 查看git文件暂存区状态 git pull 抓取远程仓库所有分支更新并合并到本地<br />git push push所有分支到远程仓库 git push origin master 将本地主分支推到远程主分支<br />git branch 显示所有分支<br />git branch newbranch 创建分支<br />git checkout branchname 切换到分支</p>

<p><strong>关于git rebase</strong><br />下面这篇<a href='http://gitbook.liuhui998.com/4_2.html'>blog</a>写的比较不错，之前没有多人开发git的经验，还是挺难理解的.</p>

<h4 id='5kmallocvmalloc'><strong>5.kmalloc和vmalloc区别</strong></h4>

<p>没用过，不知道，查了下：<br />kmalloc和vmalloc是分配的是内核的内存,malloc分配的是用户的内存</p>

<p>kmalloc保证分配的内存在物理上是连续的,vmalloc保证的是在虚拟地址空间上的连续</p>

<p>kmalloc能分配的大小有限,vmalloc和malloc能分配的大小相对较大</p>

<p>内存只有在要被DMA访问的时候才需要物理上连续，即kmalloc</p>

<p>kmalloc和 kfree管理内核段内分配的内存，这是真实地址已知的实际物理内存块。vmalloc和vfree是对内核使用的虚拟内存进行分配和释放</p>

<h4 id='6malloc'><strong>6.malloc调用的系统调用</strong></h4>

<p>不知道，查了下是brk，参见这篇<a href='http://edsionte.com/techblog/archives/4174'>blog</a></p>

<h4 id='7fork'><strong>7.fork的优化</strong></h4>

<p>这个依然不知道，fork实现的时候并不是完全复制父进程的数据段和堆栈，而是采用了<strong>写时复制（copy-on-write）COW</strong>技术。数据段和堆栈有父子进程共享，内核将他们的访问权限设为只读，父子进程中的任何一个试图修改这些区域，此时内核只为那些修改的区域的那块内存做一个副本，通常是一个page。</p>

<h4 id='8cc'>8.C/C++遇到的坑</h4>

<p>这个说了我之前遇到的链接错误，参见我的博文<a href='http://tinyfisher.github.io/c/2012/11/23/makefile/'>makefile 编写问题记录</a></p>

<h4 id='9ibmip'>9.从IBM发ip包到北邮要查那些表，子网掩码干什么的？</h4>

<p>这个知道，route表和arp表，子网掩码区分网络号和主机号，若网络号一致，表明在一个网段</p>

<h4 id='10gdb'>10.gdb怎么调试段错误</h4>

<p>没怎么用过，面试官说用backtrace</p>

<h4 id='11cpython'>11.C和Python比较</h4>

<p>水过，python方便，c执行效率高</p>

<h4 id='12'>12.中断的上部和下部（没听过啊）</h4>

<p>真不知道，听都没听过啊</p>

<h5 id='linux'>总结：由于linux组做的都是驱动方面的，所以问的可能比较深，很多都没用过，没听过，估计悲剧，所以还是尽量深的去学习研究吧，不然怎么坑蒙拐骗面试官~</h5></div>
    </article>
  </section>
  
  
  <section id="linux20130921mongodb-mmp">
    <article>
      <header>
      <h1><a href="/linux/2013/09/21/mongodb-mmp">Mongodb学习整理之内存映射机制</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-21</span></div>
    </header>
    <div class="content"><p>sql数据库在数据量达到百万级的时候性能直线下降，在建立索引的表上做一个条件查询甚至达到分钟级别查询时间，这是无法忍受的，瓶颈在于大量的磁盘i/o操作，而这些i/o操作无疑使很耗费时间的。mongodb之所以对海量数据的查询如此高效，是因为他使用了内存映射机制，避免了大量的磁盘i/o，从而大大提高了查询效率，但相应的对内存要求也比较高。ok，下面我们来看看什么是内存映射机制</p>

<h4 id='id23'>官网的说法：</h4>

<p><strong>What are memory mapped files?</strong></p>

<p>A memory-mapped file is a file with data that the operating system places in memory by way of the mmap() system call. mmap() thus maps the file to a region of virtual memory. Memory-mapped files are the critical piece of the storage engine in MongoDB. By using memory mapped files MongoDB can treat the contents of its data files as if they were in memory. This provides MongoDB with an extremely fast and simple method for accessing and manipulating data.</p>

<p><strong>How do memory mapped files work?</strong></p>

<p>Memory mapping assigns files to a block of virtual memory with a direct byte-for-byte correlation. Once mapped, the relationship between file and memory allows MongoDB to interact with the data in the file as if it were memory.</p>

<p><strong>How does MongoDB work with memory mapped files?</strong></p>

<p>MongoDB uses memory mapped files for managing and interacting with all data. MongoDB memory maps data files to memory as it accesses documents. Data that isn’t accessed is not mapped to memory.</p>

<p><strong>What are page faults?</strong></p>

<p>Page faults will occur if you’re attempting to access part of a memory-mapped file that isn’t in memory.</p>

<p>If there is free memory, then the operating system can find the page on disk and load it to memory directly. However, if there is no free memory, the operating system must:</p>

<p>find a page in memory that is stale or no longer needed, and write the page to disk.</p>

<p>read the requested page from disk and load it into memory.</p>

<p>This process, particularly on an active system can take a long time, particularly in comparison to reading a page that is already in memory.</p>

<h4 id='id24'>我的理解：</h4>

<p>首先，“映射”这个词，就和数学课上说的“一一映射”是一个意思，就是建立一种一一对应关系，在这里主要是只<em>硬盘上文件</em>的位置与进程<em>逻辑地址空间</em>中一块大小相同的区域之间的一一对应（按字节对应），如过程1所示。这种对应关系纯属是逻辑上的概念，物理上是不存在的，原因是进程的逻辑地址空间本身就是不存在的。在内存映射的过程中，<strong>并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存</strong>，这个过程由系统调用mmap()实现，所以建立内存映射的效率很高。</p>

<p><img alt='hello' src='/assets/themes/images/yxh.gif' /><br />既然建立内存映射没有进行实际的数据拷贝，那么进程又怎么能最终直接通过内存操作访问到硬盘上的文件呢？那就要看内存映射之后的几个相关的过程了。</p>

<p>mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过内存管理单元MMU将逻辑地址转换成物理地址，如图1中过程2所示。这个过程与内存映射无关。</p>

<p>前面讲过，建立内存映射并没有实际拷贝数据，这时，MMU在地址映射表中是无法找到与ptr相对应的物理地址的，也就是MMU失败，将产生一个缺页中断，缺页中断的中断响应函数会在swap中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中，如图1中过程3所示。这个过程与内存映射无关。</p>

<p>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上，如图1中过程4所示。这个过程也与内存映射无关。</p>

<p><strong>所以当mongodb读取数据库文件的时候，首先做内存映射，读取文件变成了读取内存操作，所以mongodb的查询效率相当高，当然，如果你的内存不够大，经常发生缺页中断，那么效率会大打折扣了</strong></p></div>
    </article>
  </section>
  
  
  <section id="blog20130921icap">
    <article>
      <header>
      <h1><a href="/blog/2013/09/21/icap">ICAP RFC3507 部分章节翻译</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-21</span></div>
    </header>
    <div class="content"><h4 id='icaphttprfc3507okicap'>之前项目中用到了icap协议，成功实现了对http数据包的内容修改，增加等功能，现将一些协议中一些字段进行总结，参考了RFC3507，ok，让我们首先看一个icap报文</h4>
<pre class='prettyprint linenums lang-clj'>
REQMOD  icap://127.0.0.1:1344/greasyspoon_req ICAP/1.0\r\n       
Host:127.0.0.1:1344\r\n                                     
Date:Wed, 08 May 2013 15:47:28 GMT\r\n                         
Encapsulated:req-hdr=0, null-body=336\r\n                                                      
Preview:0\r\n                                                    
Allow:204\r\n                               
\r\n                                     
GET   http://202.168.1.13/1.html HTTP/1.1\r\n                  
Host:   202.168.1.13\r\n                          
User-Agent:  Mozilla/5.0 (Windows NT 6.1; WOW64; rv:17.0) Gecko/20100101 
Firefox/17.0\r\n                        
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n  
Accept-Language:   en-US,en;q=0.5\r\n                  
Accept-Encoding:   gzip, deflate\r\n                    
Referer:  http://202.168.1.13/support.html\r\n                    
\r\n
</pre>
<p>其中1到7行为icap头，剩下的是我们常见的http头，我们一条一条看一下：<br />第一行中<code>REQMOD</code>表示icap工作在请求模式，icap还有一种模式叫<code>RESPMOD</code>，意思是工作在响应模式，<strong>简单的说，请求模式主要针对http请求报文进行匹配修改增值，响应模式主要针对http响应报文进行匹配修改增值</strong>；<code>icap://127.0.0.1:1344/greasyspoon_req ICAP/1.0</code>说的是资源url和版本号1.0，其中<code>greasyspoon</code>是指icap服务器的具体名称，icap服务器还有c-icap等。<br /><code>host</code>和<code>date</code>这里就不详细说了<br /><code>Encapsulated:req-hdr=0, null-body=336\r\n </code>说的是封装了http请求包，http头偏移量为0，这个请求包只有头，没有body，所以<code>null-body=336</code>，336是指body的偏移量；如果有请求包的body的话,例如post消息，会出现下面的情况：<br /><code>Encapsulated: req-hdr=0, req-body=412</code>,意思是头偏移长度0，bdoy偏移长度为412，通过这个可以得到http头和消息体的开始位置，<strong>总结一下，<code>Encapsulated</code>这个字段主要用来定位http消息的header和body。</strong></p>

<p>再来看<code>preview</code>字段的用途，首先看一下RFC3507中对他的描述：</p>

<pre><code>ICAP REQMOD or RESPMOD requests sent by the ICAP client to the ICAP server may include a &quot;preview&quot;. This feature allows an ICAP server to see the beginning of a transaction, then decide if it wants to opt-out of the transaction early instead of receiving the remainder of the request message.   </code></pre>

<p>翻译如下：icap客户端发送给服务端的REQMOD或者RESPMOD请求可能包含“preview” 字段，它能让icap服务端看到事务的最开始的一些信息，从而决定是否直接退出这个事务，而不是等到将所有的请求信息接收完毕再做判断。<strong>说白了就是预览icap封装消息body的前n个字节，来判断是否对这个消息进行处理，而不是接收完所有消息再判断。</strong>举个例子（RFC上的）：</p>

<pre><code>If an ICAP server wants to transcode all GIF87 files into GIF89 files, then the GIF87 files could quickly be detected by looking at the first few body bytes of the file.  </code></pre>

<p>翻译：如果icap服务器想要把所有gif87的文件转码成gif89文件，gif87的文件可以通过body的前几行检测出来。</p>

<p>这里由于我们的包里只有http header，没有http body，所以preview为0</p>

<p>最后<code>Allow:204</code>,我们先看看RFC上怎么说：<br /> An ICAP client MAY include &#8220;Allow: 204&#8221; in its request headers,indicating that the server MAY reply to the message with a &#8220;204 NoContent&#8221; response if the object does not need modification.</p>

<pre><code>If an ICAP server receives a request that does not have &quot;Allow: 204&quot;,it MUST NOT reply with a 204. In this case, an ICAP server MUST return the entire message back to the client, even though it is identical to the message it received.</code></pre>

<p>翻译：&#8221;Allow: 204&#8221;是可选的，加上这个选项表示：如果这个包不需要处理，则服务器返回&#8221;204 NoContent&#8221;给客户端，如果不加这个选项，服务器绝不会返回204，而是将整个消息返回给客户端<br /><strong>总结一下：这个allow：204主要是真针对不需要处理的数据包进行简单返回状态码204，从而减少了icap服务器和客户端的工作量</strong></p>

<h4 id='okicapicap'>ok，到这里我们基本分析了icap的请求包，再来看看，icap服务器的返回包：</h4>
<pre class='prettyprint linenums lang-clj'>
ICAP/1.0 200 OK\r\n 
ISTag:"GreasySpoon-1.0.8-01"\r\n                   
Host:0.0.0.0:1344\r\n                         
Encapsulated:req-hdr=0, null-body=333\r\n                 
Connection:close\r\n                          
\r\n                                     
GET http://202.168.2.34/2.html HTTP/1.1\r\n                 
Host:202.168.2.34\r\n                          
User-Agent:  Mozilla/5.0 (Windows NT 6.1; WOW64; rv:17.0) Gecko/20100101 
Firefox/17.0\r\n                         
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n     
Accept-Language:   en-US,en;q=0.5\r\n                   
Accept-Encoding:   gzip, deflate\r\n                     
Referer:http://202.168.1.13/support.html\r\n                   
\r\n                                     
</pre>
<p>前6行为icap响应包头，下面的是修改后的http请求，可以看到<code>GET http://202.168.2.34/1.html HTTP/1.1\r\n</code>改成了<code>GET http://202.168.2.34/2.html HTTP/1.1\r\n</code>,我们成功修改了http请求。下面具体看一下响应包的各个字段：</p>

<p><code>ICAP/1.0 200 OK\r\n </code>说的是icap的返回状态码200，表示http请求已经被成功修改，类似于http状态码200</p>

<p><code>ISTag</code>（ICAP Service Tag）说的是我们用的icap service的具体名称和版本号，我们这里用的是greasyspoon</p>

<p><code>host</code>和<code>Encapsulated</code>不再赘述了</p>

<p><code>Connection</code>字段和http协议的connection一样，含义是当client和server通信时对于长链接如何进行处理。在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close.</p>

<p>不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</p>

<h4 id='http'>顺便再复习一下http报文里的各个字段的含义：</h4>

<p>1、 Accept：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</p>

<p>2、 Accept-Charset： 浏览器申明自己接收的字符集</p>

<p>Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</p>

<p>Accept-Language：：浏览器申明自己接收的语言</p>

<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</p>

<p>3、 Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。</p>

<p>keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。</p>

<p>响应：close（连接已经关闭）。</p>

<p>keepalive（连接保持着，在等待本次连接的后续请求）。</p>

<p>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300</p>

<p>4、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn</p>

<p>5、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/</p>

<p>6、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix) 7、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14</p></div>
    </article>
  </section>
  
  
  <section id="linux20130715mongodb-install">
    <article>
      <header>
      <h1><a href="/linux/2013/07/15/mongodb-install">Mongodb 学习整理之安装</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-07-15</span></div>
    </header>
    <div class="content"><h3 id='id19'>下载</h3>

<p>下载MongoDB，此处下载的版本是：<a href='http://fastdl.mongodb.org/linux/mongodb-linux-i686-1.8.1.tgz'>mongodb-linux-i686-1.8.1.tgz.tar</a></p>

<h3 id='id20'>安装</h3>

<p><strong>step1：</strong>解压文件到某目录下,然后重命名：</p>

<pre><code>[root@localhost src]# tar -xzvf mongodb-linux-i686-1.8.1.tgz.tar    
[root@localhost src]# mv mongodb-linux-i686-1.8.1 /usr/local/mongodb/  </code></pre>

<p><strong>step2：</strong>查看安装后的文件情况：</p>

<pre><code>[root@localhost src]# cd /usr/local/mongodb/   
[root@localhost mongodb]# ls   
bin  GNU-AGPL-3.0  README  THIRD-PARTY-NOTICES   
[root@localhost mongodb]# cd bin/   
[root@localhost bin]# ls   
bsondump  dbbak  mongo  mongod  mongodump  mongoexport  mongofiles  mongoimport  mongorestore mongos  mongosniff  mongostat    </code></pre>

<p>bin下的mongod就是MongoDB的服务端进程，mongo就是其客户端，其它的命令用于MongoDB的其它用途如MongoDB文件导出等。</p>

<p><strong>step3:</strong>启动MongoDB:</p>

<p>要先建立好MongoDB 存放数据文件和日志文件的目录，需要手动建立：</p>

<pre><code>mkdir /data/mongodb_data
mkdir /data/mongodb_log
touch /data/mongodb_log/mongodb.log
[root@localhost etc]# cd /data/   
[root@localhost data]# ls   
mongodb_data  mongodb_log    </code></pre>

<p>在MongoDB安装目录下的bin下使用mongod启动MongoDB</p>

<pre><code>./mongod --dbpath=/data/mongodb_data/ --logpath=/data/mongodb_log/mongodb.log --logappend&amp;  </code></pre>

<p>等待启动成功后，可查看是否启动成功了，默认端口号是27017，当然在启动时也可以指定未使用的其它端口。先通过查看端口号看MongoDB是否启动了。</p>

<pre><code>[root@localhost data]# netstat -lanp | grep &quot;27017&quot;  
tcp   0    0 0.0.0.0:27017      0.0.0.0:*     LISTEN      1573/mongod            
unix  2  [ ACC ]    STREAM   LISTENING    5874  1573/mongod   /tmp/mongodb-27017.sock    </code></pre>

<p>可以看到，已启动成功，现在使用mongo客户端访问一下该数据库。</p>

<pre><code>[root@localhost bin]# cd /usr/local/mongodb/bin/   
[root@localhost bin]# ./mongo   
MongoDB shell version: 1.8.1  
connecting to: test   </code></pre>

<p>到这一步说明已经安装成功了。</p>

<h3 id='id21'>额外工作</h3>

<p>注意，上述我们启动MongoDB都是手动使用mongod来启动，这样关闭计算机后，下次再进来它又没启动了，所以还得手动启动，因此，为避免这种繁琐的工作，可以把mongod放到服务自启动项中，这样计算机一开启mongod服务也就启动了。编辑/etc/rc.local，加入下述代码然后再保存即可。 (也可以写一个脚本，然后开机自动运行)</p>

<pre><code>#add mongonDB service   
/usr/local/mongodb/bin/mongod --dbpath=/data/mongodb_data/ --logpath=/data/mongodb_log/mongodb.log --logappend&amp;    </code></pre>

<p>或者编写开机自启动脚本start_mongodb.sh</p>

<pre><code>cd /usr/local/mongodb-linux-i686-2.2.1/bin  //具体版本具体变化
./mongod --dbpath=/data/mongodb_data/ --logpath=/data/mongodb_log/mongodb.log --logappend&amp;   </code></pre>

<p>路径和你设置mongodb的datapath，logpath一致 我们重启计算机再看MongoDB是否启动，重启后可以直接使用 mongo命令登录，最终发现是可以成功的。</p>

<p>另外，我们使用mongo命令登录 MongoDB还要转到mongo命令所在目录再执行./mongo，这样是不是有些麻烦？因此，我们可以简化这点，将该命令文件copy到/usr/bin下，这样就可以在任何目录下使用mongo命令了。</p>

<pre><code>[root@localhost bin]# ls   
bsondump  dbbak  mongo  mongod  mongodump  mongoexport  mongofiles  mongoimport  mongorestore mongos  mongosniff  mongostat   
[root@localhost bin]# cp mongo /usr/bin/    </code></pre>

<p>转到任一目录试下mongo命令：</p>

<pre><code>[root@localhost bin]# cd /   
[root@localhost /]# mongo   
MongoDB shell version: 1.8.1  
connecting to: test   </code></pre>

<p>可以看到登录成功了，说明我们可以像使用ls命令一样使用mongo命令了。</p>

<h3 id='id22'>安装图形化界面</h3>

<p>mongoDB有许多图形化操作软件，我使用的是UMongo：</p>

<p>下载<a href='https://github.com/agirbal/umongo/downloads'>Umongo</a>,解压文件，在终端运行<code>launch-umongo.sh</code>脚本文件即可</p>

<p>ok,至此我们已经安装好了MongoDB~</p></div>
    </article>
  </section>
  
  <div class="pagination">
      <ul>
        <li><a href="/archive.html">归档</a></li>
        <li class="prev"><a href='/page2'>下一页 &rarr;</a></li>
      </ul>
  </div>
  </div>

  <aside class="span4">

    <section>
    <h4>最近发表</h4>
    <ul id="recent_posts">
      <li class="post">
        <a href="/blog/2013/09/24/factory">创新工场一面总结</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/22/ibm">IBM Linux组电面总结</a>
      </li>
      <li class="post">
        <a href="/linux/2013/09/21/mongodb-mmp">Mongodb学习整理之内存映射机制</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/21/icap">ICAP RFC3507 部分章节翻译</a>
      </li>
      <li class="post">
        <a href="/linux/2013/07/15/mongodb-install">Mongodb 学习整理之安装</a>
      </li>
      <li class="post">
        <a href="/linux/2013/07/09/mongodb-introduce">Mongodb 学习整理之介绍</a>
      </li>
      <li class="post">
        <a href="/linux/2013/06/23/hostapd">利用Hostapd搭建无线wifi</a>
      </li>
      <li class="post">
        <a href="/blog/2013/05/23/microsoft_test">2013微软暑期实习笔试错题、疑题整理</a>
      </li>
      <li class="post">
        <a href="/linux/2013/05/01/fluentd">fluentd插件开发</a>
      </li>
      <li class="post">
        <a href="/linux/2013/04/23/mongodb">Mongodb的备份与恢复</a>
      </li>
    </ul>
    </section>
    
  
    <h4>分类</h4>
    <ul class="tag_box">
      
      


  
     
    	<li><a href="/categories.html#blog-ref">
    		blog <span>5</span>
    	</a></li>
     
    	<li><a href="/categories.html#algorithm-ref">
    		algorithm <span>8</span>
    	</a></li>
     
    	<li><a href="/categories.html#link-ref">
    		link <span>2</span>
    	</a></li>
     
    	<li><a href="/categories.html#btree-ref">
    		btree <span>3</span>
    	</a></li>
     
    	<li><a href="/categories.html#vim-ref">
    		vim <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#linux-ref">
    		linux <span>11</span>
    	</a></li>
     
    	<li><a href="/categories.html#c-ref">
    		c <span>2</span>
    	</a></li>
    
  


    </ul>
  

  </aside>
</div>

  </div>
</div>


      </div>

      <footer>
        <p>&copy; tinyfisher 2013 
          基于 <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          和 <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a> 构建
        </p>
      </footer>

    </div> <!-- /container -->
    
  </body>
</html>

