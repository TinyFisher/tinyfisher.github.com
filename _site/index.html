
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tinyfisher blog</title>
    <meta name="author" content="tinyfisher">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- <link href="http://lib.sinaapp.com/js/bootstrap/latest/css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all"> -->
    <link href="http://lib.sinaapp.com/js/bootstrap/2.0.3/css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/google-code-prettify/prettify.css" rel="stylesheet" type="text/css" media="all">
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <!-- <script type="text/javascript" src="http://lib.sinaapp.com/js/bootstrap/latest/js/bootstrap.min.js"></script> -->
    <script type="text/javascript" src="http://lib.sinaapp.com/js/bootstrap/2.0.3/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/themes/twitter/google-code-prettify/prettify.js"></script>
    <script type="text/javascript" src="/assets/themes/twitter/js/application.js"></script>
  </head>

  <body data-spy="scroll" data-target=".subnav" data-offset="100">

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">tinyfisher blog</a>
          <div class="nav-collapse">
            <ul class="nav">


              <li><a href="/archive.html">归档</a></li>
              <li><a href="/categories.html">目录</a></li>
              <li><a href="/pages.html">页面</a></li>
              <li><a href="/tags.html">标签</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        


<div class="row">
  <div class="span12">
    


<div class="subnav page-launcher">
  <ul class="nav nav-pills">
    <li><a href="#algorithm20131014interview" title="面试算法题整理">面试算法题整理</a></li>
    <li><a href="#blog20130926alibaba2" title="阿里巴巴二面总结">阿里巴巴二面总结</a></li>
    <li><a href="#blog20130924factory" title="创新工场一面总结">创新工场一面总结</a></li>
    <li><a href="#blog20130922ibm" title="IBM Linux组电面总结">IBM Linux组电面总结...</a></li>
    <li><a href="#linux20130921mongodb-mmp" title="Mongodb学习整理之内存映射机制">Mongodb学习整理之内存映射机制</a></li>
  </ul>
</div>


<div class="row">
  <div class="span8">
  
  
  <section id="algorithm20131014interview">
    <article>
      <header>
      <h1><a href="/algorithm/2013/10/14/interview">面试算法题整理</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-10-14</span></div>
    </header>
    <div class="content"><p>最近面试跪了不少，都基本是跪在算法题上，现在把遇到的一些题目记录下来，方面以后复习</p>

<h4 id='10111001111000001100000014041'>1.一个字符串只有0和1，如“110011110000”，找到这个串中的最长子串，使得子串的0和1个数相等，比如：1000<code>01011100</code>0001，阴影的部分有4个0、4个1（出自美团）</h4>

<p>思路：最简单的想法就是遍历所有的子串，之后判断该子串是否满足条件N^2子串，每个子串扫一遍判断0、1是否出现的次数相等，复杂度为O(N^3)，稍加思考就会发现， <strong>如果一个长度为n的子串满足条件，加么这n个元素的和加起来一定=(n/2)</strong>，这样在循环的过程中，增量加就可以了，不需要每个子串从头计算，复杂度降为O(N^2);伪码：</p>

<pre><code>int maxlen = 0, sum = 0, currlen = 0;
for(int i = 0; i &lt; N; ++i)
{
    sum = 0;
    for(int j = i; j &lt; N; ++j)
    {
        currlen = j - i + 1;
        sum += int(A[j]);
        if(currlen%2 == 0 &amp;&amp; sum == currlen/2 &amp;&amp; currlen &gt; maxlen)
            maxlen = currlen;
	}
}</code></pre>

<p>还有没有办法进一步降低算法的复杂度呢？</p>

<p>面试官说有这样一种巧妙的解法：定义一个数据B<span>N</span>， B<span>i</span>表示从A<span>0&#8230;i</span>中 num_of_0 - num_of_1，0的个数与1的个数的差，那么如果A<span>i</span> ~ A<span>j</span>（A<span>i</span>,A<span>j</span>选一个包含）是符合条件的子串，一定有 B<span>i</span> == B<span>j</span>，因为中间的部分0、1个数相等，相减等于0。 只需要扫一遍A<span>N</span>就能把B<span>N</span>构造出来了。<strong>这样问题就转换成了求距离最远的一对数</strong>，使得B<span>i</span> == B<span>j</span>，因为B<span>i</span>的范围一定是<span>-N,N</span>，-N到N的范围都存起来，建一个-N到N的hash表，index就是-N到N，value就是index相等的两个数的最长距离，这样每扫到B<span>i</span>，如果hash表里的值还不存在，填i，若已经存在，填i和里面值得差，即为当前长度，需要更新最大长度这个值。其实代码真的非常简单，一个循环就搞定了，这就是算法和思考的乐趣:)</p>

<pre><code>int A[N],B[N];
int num[2*N + 1];
int count[2] = {0,0}, maxlen = 0, currlen = 0;
memset(C, 2*N, -1);
for(int i = 0; i &lt; N; ++i)
{
   count[ int(A[i]) ] += 1;
   B[i] = count[1] - count[0];
   if( num[ B[i] + N ] == -1)//尚不存在，B的下标是差，值是A的下标 
       num[ B[i] + N ] = i; 
   else//already exist
   {
       currlen = i - num[ B[i] + N ] + 1; //num[ B[i] + N ]是B[i]已存在的下标
       if(currlen &gt; maxlen)
           maxlen = currlen;
   }
}</code></pre>

<h4 id='2a1b2c4abbcccc'>2.编程实现把一个字符串从“a1b2c4”转成“abbcccc”，不准申请新的内存，原字符串可以认为后面的空间足够大（出自美团）</h4>

<p><strong>思路</strong>：统计所有的数字之和何以得到最终字符串的长度，然后利用两个指针str1指向原字符串尾，str2指向新字符串尾，记录str1的数字n，和前面的字符m，str2从后向前写n个m，直到str1指向第一个字符。</p>

<p><strong>问题</strong>：可能会出现覆盖问题，例如“a1b2c3”转成“abbccc”，原字符串和新字符串长度都是6，按照我上面的算法，第一步之后字符串会变成“a1bccc”，这是我无法得到b的次数2，因为2被c覆盖了。</p>

<p><strong>为什么会覆盖？</strong><br />原因在“a1”上，“a1”最后要变成“a”，原字符串多占了一位，导致后面的出现覆盖，所以对于所有的“X1”要进行预处理。</p>

<p><strong>怎么处理</strong>？<br />遍历一遍字符串，每遇到“1”，把后面的字符串向前移动一位，例如“a1b2c3”变成“ab2c3”，这个时候，再对“ab2c3”进行我之前的处理，第一步变成“ab2ccc”，是没有问题的。</p>

<p><strong>注意</strong>：因为把1去掉之后，原字符串的格式发生了变化，遍历的时候需要注意判断一下。</p>

<h4 id='33333123111'>3.整数分割，比如给定一整数3，其有如下情况：3=3,3=1+2,3=1+1+1,求一个数的所有分割组合（出自创新工场行云）</h4>

<p>n=m1+m2+&#8230;+mi; （其中mi为正整数，并且1 &lt;= mi &lt;= n），则{m1,m2,&#8230;,mi}为n的一个划分。</p>

<p>如果{m1,m2,&#8230;,mi}中的最大值不超过m，即max(m1,m2,&#8230;,mi)&lt;=m，则称它属于n的一个m划分。这里我们记n的m划分的个数为f(n,m);</p>

<p>例如n=4时，他有5个划分，{4},{3,1},{2,2},{2,1,1},{1,1,1,1};</p>

<p>该问题是求出n的所有划分个数，即f(n, n)。下面我们考虑求f(n,m)的方法;<br />根据n和m的关系，考虑以下几种情况：</p>

<p>(1) 当n=1时，不论m的值为多少（m&gt;0)，只有一种划分即{1};</p>

<p>(2) 当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,&#8230;,1};</p>

<p>(3) 当n=m时，根据划分中是否包含n，可以分为两种情况：</p>

<p>(a).划分中包含n的情况，只有一个即{n}；</p>

<p>(b).划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。</p>

<p>因此 当n=m时，f(n,n) =1 + f(n,n-1);</p>

<p>(4) 当n &lt; m时，由于划分中不可能出现负数，因此就相当于f(n,n);</p>

<p>(5) 当n &gt; m时，根据划分中是否包含最大值m，可以分为两种情况：</p>

<p>(a).划分中包含m的情况，即{m, {x1,x2,&#8230;xi}}, 其中{x1,x2,&#8230; xi} 的和为n-m，因此这种情况下为f(n-m,m)</p>

<p>(b).划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);</p>

<p>因此，当n &gt; m时 f(n, m) = f(n-m, m)+f(n,m-1);</p>

<p>综上：</p>

<pre><code>f(n,m)=1;(n=1||m=1)  

f(n,m)=f(n,n);(n&lt;m)  

f(n,m)=1+ f(n, m-1);(n=m)  

f(n,m)=f(n-m,m)+f(n,m-1); (n&gt;m)  </code></pre></div>
    </article>
  </section>
  
  
  <section id="blog20130926alibaba2">
    <article>
      <header>
      <h1><a href="/blog/2013/09/26/alibaba2">阿里巴巴二面总结</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-26</span></div>
    </header>
    <div class="content"><p>二面面试官澄观，一看就很牛逼的样子，年龄也比一面的易统大一些，拿着我的简历，顺手拿了几个零食把我带到大厅，开始面试<br /><strong>1.你擅长什么？</strong><br />我去，突出一个防不胜防，没有自我介绍，也不问项目，简历扫了一眼，扔一边。<br />这个问题不好答，我怕给自己挖一个坑，我就说linux用的还行，他说哪方面，我说系统使用方面，常用命令比较熟，他就问了一个问题，把一个文件夹里的.cpp文件中的BUPT换成alibaba，怎么实现？<br />sed -i &#8220;s/BUPT/alibaba/g&#8221; ./*.cpp</p>

<p>个人感觉这个问题就是坑啊，如果不是特别擅长，很容易被问住，好比让你在简历上选填你精通什么，然后问到你挂。<br /><strong>2.学生期间有什么可以展示的，不限技术</strong><br />随意发挥</p>

<p><strong>3.有用过多线程或者多进程么？在什么情况下用的？两者有什么区别</strong><br />项目中有个监听线程，监听到3G网卡掉线，自动重连。<br />多线程好处：节约资源，并发快<br />多进程好处：安全，即使子进程挂了，父进程不会挂 <br />多线程缺点：不安全，一个线程挂掉，整个进程挂了<br />多进程缺点：资源占用比较多，并发性不如线程</p>

<p><strong>4.apache知道吗？看过源码吗？是多进程还是多线程的？http请求方法有哪些？服务器怎么知道用户登陆过？</strong><br />知道，没看过，猜测是多进程的，GET，POST，（其余不常用，没怎么记，面试官貌似不满意）。<br />通过sessionid，用户请求时，服务器生成一个sessionid传给客户端，客户端用cookie保存sessionid，然后登陆的时候通过cookie把sessionid再发送给服务端。（大致这个意思，面试官大致满意）</p>

<p><strong>5.二叉树求深度，不准递归，树是只读的</strong><br />我的思路：用队列按层遍历，每一层加一，面试官说：你怎么知道这一层遍历完了？这里想了很久，说再用一个栈保存结果，栈为空的时候，这层完了，此时加一，面试官说：行是行，但浪费空间。</p>

<p><strong>6.求一千亿个数的中位数，这些数无序</strong><br />我的思路：hash%1000，分成小文件，求出小文件的最大和最小值，然后按照这个区间，使得这1000个小文件按照顺序排列，中位数在中间的小文件里，面试官说：不一定。发现是的，我说那我记录每个文件的个数，根据这个元素个数定位到小文件，对这个小文件排序，根据偏移量，找到中位数，面试官说对。</p>

<p><strong>总结：深入再深入，必须能有一样能征服面试官的，要有亮点，这点我还得加强，本来想说项目，直接被无视。算法题注定是难的，千万别放弃，展示出想要解决他的勇气，可以问面试官要提示，互动的解决这个问题，一旦放弃，这轮面试也就挂了。</strong></p>

<p><strong>附：http请求方式</strong></p>

<p>GET,HEAD,PUT,DELETE,POST,OPTIONS</p>

<p>但其实我们大部分情况下只用到了GET和POST。如果想设计一个符合RESTful规范的web应用程序，则这六种方法都会用到。不过即使暂时不想涉及REST，了解这六种方法的本质仍然是很有作用的。大家将会发现，原来web也是很简洁明了的。下面依次说明这六种方法。</p>

<p>GET：GET可以说是最常见的了，它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，没有body</p>

<p>HEAD：HEAD和GET本质是一样的，但只请求页面的头部。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。</p>

<p>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，<strong>PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</strong>举个例子：如一个用于提交博文的URL，/addBlog。如果用PUT，则提交的URL会是像这样的”/addBlog/abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。目前大部分博客都是这样的。显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。</p>

<p>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p>

<p>POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。</p>

<p>OPTIONS：这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p>

<p>其实还有一个TRACE方法，不过这个基本上不会用到，这里就不介绍了。以上的六种方法，我们可以跟数据库的CRUD增删改查操作对应起来：</p>

<p>CREATE ：PUT</p>

<p>READ：GET</p>

<p>UPDATE：POST</p>

<p>DELETE：DELETE</p>

<p><strong>关于session和cookie</strong></p>

<p>为什么会有cookie和session呢,大家都知道，http是无状态的协议（<strong>无状态是指，当浏览器发送请求给服务器的时候，服务器响应，但是同一个浏览器再发送请求给服务器的时候，他会响应，但是他不知道你就是刚才那个浏览器，简单地说，就是服务器不会去记得你，所以是无状态协议。</strong>），客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能实现网上商店中的购物车呢？</p>

<p>session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现，系统会创造一个名为JSESSIONID的输出cookie，我们叫做session cookie,以区别persistent cookies,也就是我们通常所说的cookie,注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，这也就是我们刚才看到的JSESSIONID，我们通常情是看不到JSESSIONID的，但是当我们把浏览器的cookie禁止后，WEB服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到sessionid=KWJHUG6JJM65HS2K6之类的字符串。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把sessionid传递回服务器。</p>

<p>Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从：<span>系统盘</span>:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p>

<p><strong>关于二叉树求深度</strong></p>

<p>思路：先层次遍历一遍找出最后一个节点，然后目的变为求这个节点的深度。然后我们用循环一层一层找到它的上一层，找到一次，深度加1，最终可以得到二叉树的深度。不需要栈了。<br />例如下面的树：<br /><img alt='hello' src='/assets/themes/images/btree.jpg' /> <br />首先按层遍历获得最后一个元素J，然后从根再次按层遍历找到他的父节点E，此时深度+1，再从头按层遍历找到E的父节点B，此时深度加1，直到根节点为止</p>

<p><strong>关于1000亿个数的中位数</strong></p>

<p>我的那种hash%1000的分割法有点问题，因为整数是有范围的，可按照整数范围分割文件，这样就不需要对每个文件排序，然后根据index偏移量找到小文件，只需对这个文件进行排序，取偏移量的数即可</p>

<p>　　</p></div>
    </article>
  </section>
  
  
  <section id="blog20130924factory">
    <article>
      <header>
      <h1><a href="/blog/2013/09/24/factory">创新工场一面总结</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-24</span></div>
    </header>
    <div class="content"><p>跟hr约好了9点去面试，早上7点半起来，觉得不出意外能赶到，结果堵车了，急得要死，还好邮件里有hr的联系方式，提前打个电话说明了情况，对方表示没有关系，这下放心了。到了创新工场是大概9:10，迟到了10分钟左右，然后被hr mm带到一个叫手舞的玻璃房里，里面坐着面试官gg，谈吐穿着都非常儒雅，气氛不算很紧张。<br />首先自我介绍，然后挑一个项目介绍，扯了扯，面试官开始直奔主题，写代码，早闻创新工场的面试就是这个样子，开始进入正题：<br /><strong>1.快排，时间复杂度，怎么避免最坏情况的出现</strong></p>

<p>砍瓜切菜，至于优化在《算法导论》中看到过，partition的时候不是固定取末尾一个数，而是随机取，甚至可以随机取3个数，取这3个数的中位数作为key。面试官比较满意。</p>

<p><strong>2.一个整型无序数组，要求从中取三个数，要求：这三个数值递增，三个数在原数组中的下标值也递增，说思路</strong><br />这题时间不够，没想出来。我的思路是：<br />1.既然无序，那我排序试试看，结果发现如果排序势必会打乱下标的顺序，跟没排序其实没区别<br />2.那么既然下标已经有序了，我就把所有符合下标递增的三元组找出来，看他们的值是否递增，面试官说：这个肯定可以，有没有优化的办法？<br />卡住了，实在想不出来了，时间也到了，后来我就问面试官，这题怎么做，他告诉了我答案：<br />举个例子：2,1,4,3,5<br />面试官说我们只需要找到总共有多少个三元组，而不需要把他们找出来，充分利用数组下标已递增的特点，固定一个数，比如说4，那么以4为中值的三元组只需要从左边找到比4小的和右边找到比4大的即可。 哎，充分感觉智商不够用。不知道还能不能进二面</p>

<p><strong>总结：基础要牢，排序神马的基本是送分题，但也要深入研究下各个排序的特点，时间复杂度，最差情况，优化等等；至于算法题，还是搞题海战术吧，我这种智商的实在想不出来</strong><br />今天收到二面通知，开心！</p></div>
    </article>
  </section>
  
  
  <section id="blog20130922ibm">
    <article>
      <header>
      <h1><a href="/blog/2013/09/22/ibm">IBM Linux组电面总结</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-22</span></div>
    </header>
    <div class="content"><p>下午四点多的突然接到IBM Linux电面，找了个安静的地方开始面试，对面GG比较友好，首先自我介绍，然后说了说项目，面试官还是很互动的，氛围比较轻松，还介绍了Linux组主要是做社区这一块，内核神马的。之后开始技术问题狂轰滥炸：</p>

<h4 id='1'><strong>1.大小端问题</strong></h4>

<p>这个才看过，总结下：小端是指低地址在低字节，正常比较容易理解的就是小端；大端是指高位在低字节，低位在高字节（比较绕）。。。<br />举个例子：0x1234，如果是小端，假设左边是内存高位，右边是内存低位，则小端存储如下：0x12,0x34；反之大端则是：0x34，0x12</p>

<h4 id='2fork'><strong>2.fork特点</strong></h4>

<p>这个回答的还不错，fork会有两个返回值，返回值为0的为子进程，返回值不为0的为父进程，其数值含义是子进程的pid</p>

<h4 id='3'><strong>3.僵尸进程</strong></h4>

<p>这个答错了，面试官问“是这样吗”之后，我就知道答错了，记混淆了。<br /><strong>我的错误回答：父进程比子进程先结束，子进程由init进程管理，子进程成为僵尸进程</strong><br />错误原因：我混淆了孤儿进程和僵尸进程的概念，我说的其实是孤儿进程。那么什么是僵尸进程呢？</p>

<p><strong>关于僵尸进程</strong><br /><strong>1.僵尸进程是怎么产生的？</strong></p>

<p>由于子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束. 那么会不会因为父进程太忙来不及wait子进程,或者说不知道子进程什么时候结束,而丢失子进程结束时的状态信息呢? 不会。因为UNIX提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是: <strong>在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放</strong>. 但这样就导致了问题,如果进程不调用wait / waitpid的话, 那么保留的那段信息就不会释放,其进程号就会一直被占用,但是系统所能使用的进程号是有限的,如果大量的产生僵死进程,将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害,应当避免。<br /><strong>总结一下：一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就变成僵尸进程。</strong></p>

<p><strong>2.僵尸进程的处理</strong><br />任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为<strong>僵尸进程(Zombie)的数据结构</strong>，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>

<h4 id='4git'>4.git</h4>

<p>面试关看我的博客是在github上写的，于是又问了我git的问题，git rebase是干什么用的？<br />我知道git add，commit，push，pull，checkout，reset，还真没用过rebase。。。</p>

<p><strong>首先回顾一下git基本命令</strong><br />git init 初始化代码仓库<br />git add file 将工作目录里的file文件修改提交到本地暂存区<br />git commit -m “commit” 将暂存区里的文件提交，备注“commit”，同时生成快照，就是一个hash值<br />git checkout file 把file回滚到修改前的状态，注意这个针对还没有提交到本地暂存区的文件，即git add之前的文件 git reset HEAD file 把file从暂存区撤离，即git add 的反操作<br />git revert &lt;$id&gt; 返回到commit id为&lt;$id&gt;的状态，本次也是一个动作，需要commit<br />git reset &#8211;hard HEAD~1 彻底回到倒数第二个commit，倒数第一个的commit会消失，文件内容也回到上个版本 git reset &#8211;soft HEAD~1 将最后一个commit撤销，但文件内容没变，只需要重新commit即可 git diff 查看本地文件和暂存区文件差别 git log 查看commit记录<br />git status 查看git文件暂存区状态 git pull 抓取远程仓库所有分支更新并合并到本地<br />git push push所有分支到远程仓库 git push origin master 将本地主分支推到远程主分支<br />git branch 显示所有分支<br />git branch newbranch 创建分支<br />git checkout branchname 切换到分支</p>

<p><strong>关于git rebase</strong><br />下面这篇<a href='http://gitbook.liuhui998.com/4_2.html'>blog</a>写的比较不错，之前没有多人开发git的经验，还是挺难理解的.</p>

<h4 id='5kmallocvmalloc'><strong>5.kmalloc和vmalloc区别</strong></h4>

<p>没用过，不知道，查了下：<br />kmalloc和vmalloc是分配的是内核的内存,malloc分配的是用户的内存</p>

<p>kmalloc保证分配的内存在物理上是连续的,vmalloc保证的是在虚拟地址空间上的连续</p>

<p>kmalloc能分配的大小有限,vmalloc和malloc能分配的大小相对较大</p>

<p>内存只有在要被DMA访问的时候才需要物理上连续，即kmalloc</p>

<p>kmalloc和 kfree管理内核段内分配的内存，这是真实地址已知的实际物理内存块。vmalloc和vfree是对内核使用的虚拟内存进行分配和释放</p>

<h4 id='6malloc'><strong>6.malloc调用的系统调用</strong></h4>

<p>不知道，查了下是brk，参见这篇<a href='http://edsionte.com/techblog/archives/4174'>blog</a></p>

<h4 id='7fork'><strong>7.fork的优化</strong></h4>

<p>这个依然不知道，fork实现的时候并不是完全复制父进程的数据段和堆栈，而是采用了<strong>写时复制（copy-on-write）COW</strong>技术。数据段和堆栈有父子进程共享，内核将他们的访问权限设为只读，父子进程中的任何一个试图修改这些区域，此时内核只为那些修改的区域的那块内存做一个副本，通常是一个page。</p>

<h4 id='8cc'>8.C/C++遇到的坑</h4>

<p>这个说了我之前遇到的链接错误，参见我的博文<a href='http://tinyfisher.github.io/c/2012/11/23/makefile/'>makefile 编写问题记录</a></p>

<h4 id='9ibmip'>9.从IBM发ip包到北邮要查那些表，子网掩码干什么的？</h4>

<p>这个知道，route表和arp表，子网掩码区分网络号和主机号，若网络号一致，表明在一个网段</p>

<h4 id='10gdb'>10.gdb怎么调试段错误</h4>

<p>没怎么用过，面试官说用backtrace</p>

<h4 id='11cpython'>11.C和Python比较</h4>

<p>水过，python方便，c执行效率高</p>

<h4 id='12'>12.中断的上部和下部（没听过啊）</h4>

<p>真不知道，听都没听过啊</p>

<h5 id='linux'>总结：由于linux组做的都是驱动方面的，所以问的可能比较深，很多都没用过，没听过，估计悲剧，所以还是尽量深的去学习研究吧，不然怎么坑蒙拐骗面试官~</h5></div>
    </article>
  </section>
  
  
  <section id="linux20130921mongodb-mmp">
    <article>
      <header>
      <h1><a href="/linux/2013/09/21/mongodb-mmp">Mongodb学习整理之内存映射机制</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-21</span></div>
    </header>
    <div class="content"><p>sql数据库在数据量达到百万级的时候性能直线下降，在建立索引的表上做一个条件查询甚至达到分钟级别查询时间，这是无法忍受的，瓶颈在于大量的磁盘i/o操作，而这些i/o操作无疑使很耗费时间的。mongodb之所以对海量数据的查询如此高效，是因为他使用了内存映射机制，避免了大量的磁盘i/o，从而大大提高了查询效率，但相应的对内存要求也比较高。ok，下面我们来看看什么是内存映射机制</p>

<h4 id='id27'>官网的说法：</h4>

<p><strong>What are memory mapped files?</strong></p>

<p>A memory-mapped file is a file with data that the operating system places in memory by way of the mmap() system call. mmap() thus maps the file to a region of virtual memory. Memory-mapped files are the critical piece of the storage engine in MongoDB. By using memory mapped files MongoDB can treat the contents of its data files as if they were in memory. This provides MongoDB with an extremely fast and simple method for accessing and manipulating data.</p>

<p><strong>How do memory mapped files work?</strong></p>

<p>Memory mapping assigns files to a block of virtual memory with a direct byte-for-byte correlation. Once mapped, the relationship between file and memory allows MongoDB to interact with the data in the file as if it were memory.</p>

<p><strong>How does MongoDB work with memory mapped files?</strong></p>

<p>MongoDB uses memory mapped files for managing and interacting with all data. MongoDB memory maps data files to memory as it accesses documents. Data that isn’t accessed is not mapped to memory.</p>

<p><strong>What are page faults?</strong></p>

<p>Page faults will occur if you’re attempting to access part of a memory-mapped file that isn’t in memory.</p>

<p>If there is free memory, then the operating system can find the page on disk and load it to memory directly. However, if there is no free memory, the operating system must:</p>

<p>find a page in memory that is stale or no longer needed, and write the page to disk.</p>

<p>read the requested page from disk and load it into memory.</p>

<p>This process, particularly on an active system can take a long time, particularly in comparison to reading a page that is already in memory.</p>

<h4 id='id28'>我的理解：</h4>

<p>首先，“映射”这个词，就和数学课上说的“一一映射”是一个意思，就是建立一种一一对应关系，在这里主要是只<em>硬盘上文件</em>的位置与进程<em>逻辑地址空间</em>中一块大小相同的区域之间的一一对应（按字节对应），如过程1所示。这种对应关系纯属是逻辑上的概念，物理上是不存在的，原因是进程的逻辑地址空间本身就是不存在的。在内存映射的过程中，<strong>并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存</strong>，这个过程由系统调用mmap()实现，所以建立内存映射的效率很高。</p>

<p><img alt='hello' src='/assets/themes/images/yxh.gif' /><br />既然建立内存映射没有进行实际的数据拷贝，那么进程又怎么能最终直接通过内存操作访问到硬盘上的文件呢？那就要看内存映射之后的几个相关的过程了。</p>

<p>mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过内存管理单元MMU将逻辑地址转换成物理地址，如图1中过程2所示。这个过程与内存映射无关。</p>

<p>前面讲过，建立内存映射并没有实际拷贝数据，这时，MMU在地址映射表中是无法找到与ptr相对应的物理地址的，也就是MMU失败，将产生一个缺页中断，缺页中断的中断响应函数会在swap中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中，如图1中过程3所示。这个过程与内存映射无关。</p>

<p>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上，如图1中过程4所示。这个过程也与内存映射无关。</p>

<p><strong>所以当mongodb读取数据库文件的时候，首先做内存映射，读取文件变成了读取内存操作，所以mongodb的查询效率相当高，当然，如果你的内存不够大，经常发生缺页中断，那么效率会大打折扣了</strong></p></div>
    </article>
  </section>
  
  <div class="pagination">
      <ul>
        <li><a href="/archive.html">归档</a></li>
        <li class="prev"><a href='/page2'>下一页 &rarr;</a></li>
      </ul>
  </div>
  </div>

  <aside class="span4">

    <section>
    <h4>最近发表</h4>
    <ul id="recent_posts">
      <li class="post">
        <a href="/algorithm/2013/10/14/interview">面试算法题整理</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/26/alibaba2">阿里巴巴二面总结</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/24/factory">创新工场一面总结</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/22/ibm">IBM Linux组电面总结</a>
      </li>
      <li class="post">
        <a href="/linux/2013/09/21/mongodb-mmp">Mongodb学习整理之内存映射机制</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/21/icap">ICAP RFC3507 部分章节翻译</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/20/alibaba">阿里巴巴面试总结</a>
      </li>
      <li class="post">
        <a href="/linux/2013/07/15/mongodb-install">Mongodb 学习整理之安装</a>
      </li>
      <li class="post">
        <a href="/linux/2013/07/09/mongodb-introduce">Mongodb 学习整理之介绍</a>
      </li>
      <li class="post">
        <a href="/linux/2013/06/23/hostapd">利用Hostapd搭建无线wifi</a>
      </li>
    </ul>
    </section>
    
  
    <h4>分类</h4>
    <ul class="tag_box">
      
      


  
     
    	<li><a href="/categories.html#blog-ref">
    		blog <span>7</span>
    	</a></li>
     
    	<li><a href="/categories.html#algorithm-ref">
    		algorithm <span>9</span>
    	</a></li>
     
    	<li><a href="/categories.html#link-ref">
    		link <span>2</span>
    	</a></li>
     
    	<li><a href="/categories.html#btree-ref">
    		btree <span>3</span>
    	</a></li>
     
    	<li><a href="/categories.html#vim-ref">
    		vim <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#linux-ref">
    		linux <span>11</span>
    	</a></li>
     
    	<li><a href="/categories.html#c-ref">
    		c <span>2</span>
    	</a></li>
    
  


    </ul>
  

  </aside>
</div>

  </div>
</div>


      </div>

      <footer>
        <p>&copy; tinyfisher 2013 
          基于 <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          和 <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a> 构建
        </p>
      </footer>

    </div> <!-- /container -->
    
  </body>
</html>

