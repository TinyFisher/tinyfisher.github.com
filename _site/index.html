
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tinyfisher blog</title>
    <meta name="author" content="tinyfisher">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- <link href="http://lib.sinaapp.com/js/bootstrap/latest/css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all"> -->
    <link href="http://lib.sinaapp.com/js/bootstrap/2.0.3/css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/google-code-prettify/prettify.css" rel="stylesheet" type="text/css" media="all">
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <!-- <script type="text/javascript" src="http://lib.sinaapp.com/js/bootstrap/latest/js/bootstrap.min.js"></script> -->
    <script type="text/javascript" src="http://lib.sinaapp.com/js/bootstrap/2.0.3/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="/assets/themes/twitter/google-code-prettify/prettify.js"></script>
    <script type="text/javascript" src="/assets/themes/twitter/js/application.js"></script>
  </head>

  <body data-spy="scroll" data-target=".subnav" data-offset="100">

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">tinyfisher blog</a>
          <div class="nav-collapse">
            <ul class="nav">


              <li><a href="/archive.html">归档</a></li>
              <li><a href="/categories.html">目录</a></li>
              <li><a href="/pages.html">页面</a></li>
              <li><a href="/tags.html">标签</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        


<div class="row">
  <div class="span12">
    


<div class="subnav page-launcher">
  <ul class="nav nav-pills">
    <li><a href="#linux20130922mongodb-mmp" title="Mongodb 学习整理之内存映射机制">Mongodb 学习整理之内存映射机制...</a></li>
    <li><a href="#blog20130921icap" title="ICAP RFC3507 部分章节翻译">ICAP RFC3507...</a></li>
    <li><a href="#blog20130920alibaba" title="阿里巴巴面试总结">阿里巴巴面试总结</a></li>
    <li><a href="#linux20130715mongodb-install" title="Mongodb 学习整理之安装">Mongodb 学习整理之安装...</a></li>
    <li><a href="#linux20130709mongodb-introduce" title="Mongodb 学习整理之介绍">Mongodb 学习整理之介绍...</a></li>
  </ul>
</div>


<div class="row">
  <div class="span8">
  
  
  <section id="linux20130922mongodb-mmp">
    <article>
      <header>
      <h1><a href="/linux/2013/09/22/mongodb-mmp">Mongodb 学习整理之内存映射机制</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-22</span></div>
    </header>
    <div class="content"><p>sql数据库在数据量达到百万级的时候性能直线下降，在建立索引的表上做一个条件查询甚至达到分钟级别查询时间，这是无法忍受的，瓶颈在于大量的磁盘i/o操作，而这些i/o操作无疑使很耗费时间的。mongodb之所以对海量数据的查询如此高效，是因为他使用了内存映射机制，避免了大量的磁盘i/o，从而大大提高了查询效率，但相应的对内存要求也比较高。ok，下面我们来看看什么是内存映射机制</p>

<h4 id='id27'>官网的说法：</h4>

<p><strong>What are memory mapped files?</strong></p>

<p>A memory-mapped file is a file with data that the operating system places in memory by way of the mmap() system call. mmap() thus maps the file to a region of virtual memory. Memory-mapped files are the critical piece of the storage engine in MongoDB. By using memory mapped files MongoDB can treat the contents of its data files as if they were in memory. This provides MongoDB with an extremely fast and simple method for accessing and manipulating data.</p>

<p><strong>How do memory mapped files work?</strong></p>

<p>Memory mapping assigns files to a block of virtual memory with a direct byte-for-byte correlation. Once mapped, the relationship between file and memory allows MongoDB to interact with the data in the file as if it were memory.</p>

<p><strong>How does MongoDB work with memory mapped files?</strong></p>

<p>MongoDB uses memory mapped files for managing and interacting with all data. MongoDB memory maps data files to memory as it accesses documents. Data that isn’t accessed is not mapped to memory.</p>

<p><strong>What are page faults?</strong></p>

<p>Page faults will occur if you’re attempting to access part of a memory-mapped file that isn’t in memory.</p>

<p>If there is free memory, then the operating system can find the page on disk and load it to memory directly. However, if there is no free memory, the operating system must:</p>

<p>find a page in memory that is stale or no longer needed, and write the page to disk.</p>

<p>read the requested page from disk and load it into memory.</p>

<p>This process, particularly on an active system can take a long time, particularly in comparison to reading a page that is already in memory.</p>

<h4 id='id28'>我的理解：</h4>

<p>首先，“映射”这个词，就和数学课上说的“一一映射”是一个意思，就是建立一种一一对应关系，在这里主要是只<em>硬盘上文件</em>的位置与进程<em>逻辑地址空间</em>中一块大小相同的区域之间的一一对应（按字节对应），如过程1所示。这种对应关系纯属是逻辑上的概念，物理上是不存在的，原因是进程的逻辑地址空间本身就是不存在的。在内存映射的过程中，<strong>并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存</strong>，这个过程由系统调用mmap()实现，所以建立内存映射的效率很高。<br /><img alt='alt text' src='../../assets/themes/images/yxh.gif' /></p>

<p>既然建立内存映射没有进行实际的数据拷贝，那么进程又怎么能最终直接通过内存操作访问到硬盘上的文件呢？那就要看内存映射之后的几个相关的过程了。</p>

<p>mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过内存管理单元MMU将逻辑地址转换成物理地址，如图1中过程2所示。这个过程与内存映射无关。</p>

<p>前面讲过，建立内存映射并没有实际拷贝数据，这时，MMU在地址映射表中是无法找到与ptr相对应的物理地址的，也就是MMU失败，将产生一个缺页中断，缺页中断的中断响应函数会在swap中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中，如图1中过程3所示。这个过程与内存映射无关。</p>

<p>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上，如图1中过程4所示。这个过程也与内存映射无关。</p>

<p>所以当mongodb读取数据库文件的时候，首先做内存映射，读取文件变成了读取内存操作，所以mongodb的查询效率相当高，当然，如果你的内存不够大，经常发生缺页中断，那么效率会大打折扣了</p></div>
    </article>
  </section>
  
  
  <section id="blog20130921icap">
    <article>
      <header>
      <h1><a href="/blog/2013/09/21/icap">ICAP RFC3507 部分章节翻译</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-21</span></div>
    </header>
    <div class="content"><h4 id='icaphttprfc3507okicap'>之前项目中用到了icap协议，成功实现了对http数据包的内容修改，增加等功能，现将一些协议中一些字段进行总结，参考了RFC3507，ok，让我们首先看一个icap报文</h4>
<pre class='prettyprint linenums lang-clj'>
REQMOD  icap://127.0.0.1:1344/greasyspoon_req ICAP/1.0\r\n       
Host:127.0.0.1:1344\r\n                                     
Date:Wed, 08 May 2013 15:47:28 GMT\r\n                         
Encapsulated:req-hdr=0, null-body=336\r\n                                                      
Preview:0\r\n                                                    
Allow:204\r\n                               
\r\n                                     
GET   http://202.168.1.13/1.html HTTP/1.1\r\n                  
Host:   202.168.1.13\r\n                          
User-Agent:  Mozilla/5.0 (Windows NT 6.1; WOW64; rv:17.0) Gecko/20100101 
Firefox/17.0\r\n                        
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n  
Accept-Language:   en-US,en;q=0.5\r\n                  
Accept-Encoding:   gzip, deflate\r\n                    
Referer:  http://202.168.1.13/support.html\r\n                    
\r\n
</pre>
<p>其中1到7行为icap头，剩下的是我们常见的http头，我们一条一条看一下：<br />第一行中<code>REQMOD</code>表示icap工作在请求模式，icap还有一种模式叫<code>RESPMOD</code>，意思是工作在响应模式，<strong>简单的说，请求模式主要针对http请求报文进行匹配修改增值，响应模式主要针对http响应报文进行匹配修改增值</strong>；<code>icap://127.0.0.1:1344/greasyspoon_req ICAP/1.0</code>说的是资源url和版本号1.0，其中<code>greasyspoon</code>是指icap服务器的具体名称，icap服务器还有c-icap等。<br /><code>host</code>和<code>date</code>这里就不详细说了<br /><code>Encapsulated:req-hdr=0, null-body=336\r\n </code>说的是封装了http请求包，http头偏移量为0，这个请求包只有头，没有body，所以<code>null-body=336</code>，336是指body的偏移量；如果有请求包的body的话,例如post消息，会出现下面的情况：<br /><code>Encapsulated: req-hdr=0, req-body=412</code>,意思是头偏移长度0，bdoy偏移长度为412，通过这个可以得到http头和消息体的开始位置，<strong>总结一下，<code>Encapsulated</code>这个字段主要用来定位http消息的header和body。</strong></p>

<p>再来看<code>preview</code>字段的用途，首先看一下RFC3507中对他的描述：</p>

<pre><code>ICAP REQMOD or RESPMOD requests sent by the ICAP client to the ICAP server may include a &quot;preview&quot;. This feature allows an ICAP server to see the beginning of a transaction, then decide if it wants to opt-out of the transaction early instead of receiving the remainder of the request message.   </code></pre>

<p>翻译如下：icap客户端发送给服务端的REQMOD或者RESPMOD请求可能包含“preview” 字段，它能让icap服务端看到事务的最开始的一些信息，从而决定是否直接退出这个事务，而不是等到将所有的请求信息接收完毕再做判断。<strong>说白了就是预览icap封装消息body的前n个字节，来判断是否对这个消息进行处理，而不是接收完所有消息再判断。</strong>举个例子（RFC上的）：</p>

<pre><code>If an ICAP server wants to transcode all GIF87 files into GIF89 files, then the GIF87 files could quickly be detected by looking at the first few body bytes of the file.  </code></pre>

<p>翻译：如果icap服务器想要把所有gif87的文件转码成gif89文件，gif87的文件可以通过body的前几行检测出来。</p>

<p>这里由于我们的包里只有http header，没有http body，所以preview为0</p>

<p>最后<code>Allow:204</code>,我们先看看RFC上怎么说：<br /> An ICAP client MAY include &#8220;Allow: 204&#8221; in its request headers,indicating that the server MAY reply to the message with a &#8220;204 NoContent&#8221; response if the object does not need modification.</p>

<pre><code>If an ICAP server receives a request that does not have &quot;Allow: 204&quot;,it MUST NOT reply with a 204. In this case, an ICAP server MUST return the entire message back to the client, even though it is identical to the message it received.</code></pre>

<p>翻译：&#8221;Allow: 204&#8221;是可选的，加上这个选项表示：如果这个包不需要处理，则服务器返回&#8221;204 NoContent&#8221;给客户端，如果不加这个选项，服务器绝不会返回204，而是将整个消息返回给客户端<br /><strong>总结一下：这个allow：204主要是真针对不需要处理的数据包进行简单返回状态码204，从而减少了icap服务器和客户端的工作量</strong></p>

<h4 id='okicapicap'>ok，到这里我们基本分析了icap的请求包，再来看看，icap服务器的返回包：</h4>
<pre class='prettyprint linenums lang-clj'>
ICAP/1.0 200 OK\r\n 
ISTag:"GreasySpoon-1.0.8-01"\r\n                   
Host:0.0.0.0:1344\r\n                         
Encapsulated:req-hdr=0, null-body=333\r\n                 
Connection:close\r\n                          
\r\n                                     
GET http://202.168.2.34/2.html HTTP/1.1\r\n                 
Host:202.168.2.34\r\n                          
User-Agent:  Mozilla/5.0 (Windows NT 6.1; WOW64; rv:17.0) Gecko/20100101 
Firefox/17.0\r\n                         
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n     
Accept-Language:   en-US,en;q=0.5\r\n                   
Accept-Encoding:   gzip, deflate\r\n                     
Referer:http://202.168.1.13/support.html\r\n                   
\r\n                                     
</pre>
<p>前6行为icap响应包头，下面的是修改后的http请求，可以看到<code>GET http://202.168.2.34/1.html HTTP/1.1\r\n</code>改成了<code>GET http://202.168.2.34/2.html HTTP/1.1\r\n</code>,我们成功修改了http请求。下面具体看一下响应包的各个字段：</p>

<p><code>ICAP/1.0 200 OK\r\n </code>说的是icap的返回状态码200，表示http请求已经被成功修改，类似于http状态码200</p>

<p><code>ISTag</code>（ICAP Service Tag）说的是我们用的icap service的具体名称和版本号，我们这里用的是greasyspoon</p>

<p><code>host</code>和<code>Encapsulated</code>不再赘述了</p>

<p><code>Connection</code>字段和http协议的connection一样，含义是当client和server通信时对于长链接如何进行处理。在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close.</p>

<p>不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</p>

<h4 id='http'>顺便再复习一下http报文里的各个字段的含义：</h4>

<p>1、 Accept：告诉WEB服务器自己接受什么介质类型，<em>/</em> 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</p>

<p>2、 Accept-Charset： 浏览器申明自己接收的字符集</p>

<p>Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</p>

<p>Accept-Language：：浏览器申明自己接收的语言</p>

<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</p>

<p>3、 Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。</p>

<p>keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。</p>

<p>响应：close（连接已经关闭）。</p>

<p>keepalive（连接保持着，在等待本次连接的后续请求）。</p>

<p>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300</p>

<p>4、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn</p>

<p>5、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/</p>

<p>6、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix) 7、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14</p></div>
    </article>
  </section>
  
  
  <section id="blog20130920alibaba">
    <article>
      <header>
      <h1><a href="/blog/2013/09/20/alibaba">阿里巴巴面试总结</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-09-20</span></div>
    </header>
    <div class="content"><p>15号接到阿里通知，18号上午去面试，研究生期间第一次面试，颇为激动，准备了一番，18号去了大望路那里。前台签到后，在大厅等了一会，面试官拿着我的简历叫我跟他走，到了一个会议室，里面人很多，面试官的花名叫易统，阿里每个人都有花名，武侠风浓烈，马云的花名叫风清扬。。。易统说欢迎来面试，让我自我介绍，期间点开了我的blog- -</p>

<p>后来主要是围绕简历上写得项目的技能，做了一些提问，主要是我在说，面试官如果感兴趣会深入问下去。时间在一个小时左右，易统十分友好，没有什么压力，问的问题待会详细记录。最后易统说今天的面试就到这里，让我回去了，我想完蛋了，因为之前得知如果面的好会直接二面的，看来是面挂了，而我自我感觉还不错，后来细想想，可能某些问题回答的不够深入，要反思了。问题总结如下：</p>

<h4 id='tcpip'>tcp/ip三次握手</h4>

<p>这个基本是滥问题了，答得还不错</p>

<h4 id='tcp'>tcp有哪些机制保证了他的可靠性</h4>

<p>这个答得不够好，这里总结下：</p>

<h5 id='id23'>可靠性包括以下几个方面：</h5>

<p>1.能够处理数据传输过程中被破坏问题。</p>

<p>2.能够处理重复数据接收问题。</p>

<p>3.能够发现数据丢失以及对此进行有效解决。</p>

<p>4.能够处理接收端数据乱序到达问题。</p>

<h5 id='id24'>怎么保证解决上述问题？</h5>

<p>TCP协议规范和当前绝大多数TCP 协议实现代码均采用数据重传和数据确认应答机制来完成TCP 协议的可靠性数据传输。数据超时重传和数据应答机制的基本前提是对每个传输的字节进行编号，即我们通常所说的序列号。数据超时重传是发送端在某个数据包发送出去，在一段固定时间后如果没有收到对该数据包的确认应答，则（假定该数据包在传输过程中丢失）重新发送该数据包。而数据确认应答是指接收端在成功接收到一个有效数据包后，发送一个确认应答数据包给发送端主机，该确认应答数据包中所包含的应答序列号即指已接收到的数据中最后一个字节的序列号加1，加1 的目的在于指出此时接收端期望接收的下一个数据包中第一个字节的序列号。<strong>数据超时重传、数据确认应答以及对每个传输的字节分配序列号是TCP 协议提供可靠性数据传输的核心本质。</strong></p>

<p>1.解决数据传输中被破坏的问题</p>

<p>首先通过对所接收数据包的<strong>CRC校验</strong>，确认该数据包中数据是否存在错误。如果有，则简单丢弃或者发送一个应答数据包重新对这些数据进行请求。发送端在等待一段时间后，则会重新发送这些数据。本质上，数据传输错误的解决是通过<strong>数据重传机制</strong>完成的。</p>

<p>2.解决重复数据接收问题<br />接到数据包之后，查看序列号，如果数据包已经接收过，则丢弃该数据包，返回确认信息，主要是通过<strong>序列号</strong>解决这个问题</p>

<p>3.解决数据丢失问题<br />主要依靠tcp的<strong>重传机制</strong>来解决。TCP通过在发送数据报文时设置一个超时定时器来解决这种问题，如果在定时器溢出时还没有收到来自对端对发送报文的确认，它就重传该数据报文。</p>

<p>4.解决乱序问题<br />如果通信双方存在多条传输路径， 则有可能出现数据乱序问题，即序列号较大的数据先于序列号较小的数据到达，而发送端确实是按序列号由小到大的顺序发送的。数据乱序的本质是数据都成功到达了，但到达的顺序不尽如人意。对于收到的乱序报文并不丢弃，而是缓存下来(这样做是为了减少更多的重传)，立即发送希望接受的报文确认。对这个问题的解决相对比较简单，只需对这些数据进行重新排序即可。本质上，对数据乱序问题的解决是通过<strong>排序数据序列号</strong>完成的。</p>

<h4 id='syn_flood_'>syn flood 攻击</h4>

<p>由于是安全专业的，面试官又问了我这个问题，答得一般，总结如下：</p>

<h5 id='synflood'>什么是synflood？</h5>

<p>在TCP连接的三次握手中，假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）；一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，<strong>服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源</strong>&#8212;-数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的CPU时间和内存，何况还要不断对这个列表中的IP进行SYN+ACK的重试。实际上如果服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃&#8212;即使服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYN Flood攻击（SYN洪水攻击）。</p>

<h5 id='syn_flood'>怎么检测Syn flood？</h5>

<p>1、服务端无法提供正常的TCP服务。连接请求被拒绝或超时；</p>

<p>2、通过 <code>netstat -an</code> 命令检查系统，发现有大量的<code>SYN_RECV</code>连接状态。</p>

<h5 id='id25'>如何防范？</h5>

<ol>
<li>
<p>缩短SYN- Timeout时间</p>
</li>

<li>
<p>设置每秒最多3个syn封包进入</p>
</li>
</ol>

<h4 id='linux_cpu'>查看Linux CPU使用率命令</h4>

<p><code>top</code></p>

<h4 id='id26'>查看进程信息</h4>

<p><code>ps -aux</code></p>

<h4 id='vim100200'>vim从100到200行替换字符串</h4>

<p><code>:100,200s/vivian/sky/g</code></p>

<h4 id='fluentdmongodboffer23'>总结：简历上写的尽量往深处了解，面试官可能追问具体的机制，例如我用到的几个工具，fluentd，mongodb，我只是简单的使用，不清楚里面的实现机制，往往不能令面试官满意。面试失败的还有一个原因是简历上写的一定是自己非常了解的，不是很懂的还是不要往上写了，或者写了赶紧去补功课，路漫漫其修远兮，找工作是一个虐心的过程，相信经过不断的积攒经验，一定能够拿到满意的offer，下一站：创新工场23号面试，加油！</h4></div>
    </article>
  </section>
  
  
  <section id="linux20130715mongodb-install">
    <article>
      <header>
      <h1><a href="/linux/2013/07/15/mongodb-install">Mongodb 学习整理之安装</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-07-15</span></div>
    </header>
    <div class="content"><h3 id='id19'>下载</h3>

<p>下载MongoDB，此处下载的版本是：<a href='http://fastdl.mongodb.org/linux/mongodb-linux-i686-1.8.1.tgz'>mongodb-linux-i686-1.8.1.tgz.tar</a></p>

<h3 id='id20'>安装</h3>

<p><strong>step1：</strong>解压文件到某目录下,然后重命名：</p>

<pre><code>[root@localhost src]# tar -xzvf mongodb-linux-i686-1.8.1.tgz.tar    
[root@localhost src]# mv mongodb-linux-i686-1.8.1 /usr/local/mongodb/  </code></pre>

<p><strong>step2：</strong>查看安装后的文件情况：</p>

<pre><code>[root@localhost src]# cd /usr/local/mongodb/   
[root@localhost mongodb]# ls   
bin  GNU-AGPL-3.0  README  THIRD-PARTY-NOTICES   
[root@localhost mongodb]# cd bin/   
[root@localhost bin]# ls   
bsondump  dbbak  mongo  mongod  mongodump  mongoexport  mongofiles  mongoimport  mongorestore mongos  mongosniff  mongostat    </code></pre>

<p>bin下的mongod就是MongoDB的服务端进程，mongo就是其客户端，其它的命令用于MongoDB的其它用途如MongoDB文件导出等。</p>

<p><strong>step3:</strong>启动MongoDB:</p>

<p>要先建立好MongoDB 存放数据文件和日志文件的目录，需要手动建立：</p>

<pre><code>mkdir /data/mongodb_data
mkdir /data/mongodb_log
touch /data/mongodb_log/mongodb.log
[root@localhost etc]# cd /data/   
[root@localhost data]# ls   
mongodb_data  mongodb_log    </code></pre>

<p>在MongoDB安装目录下的bin下使用mongod启动MongoDB</p>

<pre><code>./mongod --dbpath=/data/mongodb_data/ --logpath=/data/mongodb_log/mongodb.log --logappend&amp;  </code></pre>

<p>等待启动成功后，可查看是否启动成功了，默认端口号是27017，当然在启动时也可以指定未使用的其它端口。先通过查看端口号看MongoDB是否启动了。</p>

<pre><code>[root@localhost data]# netstat -lanp | grep &quot;27017&quot;  
tcp   0    0 0.0.0.0:27017      0.0.0.0:*     LISTEN      1573/mongod            
unix  2  [ ACC ]    STREAM   LISTENING    5874  1573/mongod   /tmp/mongodb-27017.sock    </code></pre>

<p>可以看到，已启动成功，现在使用mongo客户端访问一下该数据库。</p>

<pre><code>[root@localhost bin]# cd /usr/local/mongodb/bin/   
[root@localhost bin]# ./mongo   
MongoDB shell version: 1.8.1  
connecting to: test   </code></pre>

<p>到这一步说明已经安装成功了。</p>

<h3 id='id21'>额外工作</h3>

<p>注意，上述我们启动MongoDB都是手动使用mongod来启动，这样关闭计算机后，下次再进来它又没启动了，所以还得手动启动，因此，为避免这种繁琐的工作，可以把mongod放到服务自启动项中，这样计算机一开启mongod服务也就启动了。编辑/etc/rc.local，加入下述代码然后再保存即可。 (也可以写一个脚本，然后开机自动运行)</p>

<pre><code>#add mongonDB service   
/usr/local/mongodb/bin/mongod --dbpath=/data/mongodb_data/ --logpath=/data/mongodb_log/mongodb.log --logappend&amp;    </code></pre>

<p>或者编写开机自启动脚本start_mongodb.sh</p>

<pre><code>cd /usr/local/mongodb-linux-i686-2.2.1/bin  //具体版本具体变化
./mongod --dbpath=/data/mongodb_data/ --logpath=/data/mongodb_log/mongodb.log --logappend&amp;   </code></pre>

<p>路径和你设置mongodb的datapath，logpath一致 我们重启计算机再看MongoDB是否启动，重启后可以直接使用 mongo命令登录，最终发现是可以成功的。</p>

<p>另外，我们使用mongo命令登录 MongoDB还要转到mongo命令所在目录再执行./mongo，这样是不是有些麻烦？因此，我们可以简化这点，将该命令文件copy到/usr/bin下，这样就可以在任何目录下使用mongo命令了。</p>

<pre><code>[root@localhost bin]# ls   
bsondump  dbbak  mongo  mongod  mongodump  mongoexport  mongofiles  mongoimport  mongorestore mongos  mongosniff  mongostat   
[root@localhost bin]# cp mongo /usr/bin/    </code></pre>

<p>转到任一目录试下mongo命令：</p>

<pre><code>[root@localhost bin]# cd /   
[root@localhost /]# mongo   
MongoDB shell version: 1.8.1  
connecting to: test   </code></pre>

<p>可以看到登录成功了，说明我们可以像使用ls命令一样使用mongo命令了。</p>

<h3 id='id22'>安装图形化界面</h3>

<p>mongoDB有许多图形化操作软件，我使用的是UMongo：</p>

<p>下载<a href='https://github.com/agirbal/umongo/downloads'>Umongo</a>,解压文件，在终端运行<code>launch-umongo.sh</code>脚本文件即可</p>

<p>ok,至此我们已经安装好了MongoDB~</p></div>
    </article>
  </section>
  
  
  <section id="linux20130709mongodb-introduce">
    <article>
      <header>
      <h1><a href="/linux/2013/07/09/mongodb-introduce">Mongodb 学习整理之介绍</a></h1>
      <div class="date">tinyfisher 发表于 <span>2013-07-09</span></div>
    </header>
    <div class="content"><h2 id='what_is_mongodb'>What is Mongodb?</h2>

<p>MongoDB是一个高性能，开源，无模式的文档型数据库，是当前<strong>NoSQL</strong>数据库产品中最热门的一种。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式。那什么是NoSQL呢？</p>

<h3 id='what_is_nosql'>What is NoSQL?</h3>

<p>NoSQL，全称是”<strong>Not Only Sql</strong>”,指的是非关系型的数据库。这类数据库主要有这些特点：非关系型的、分布式的、开源的、水平可扩展的。原始的目的是为了大规模web应用。NoSQL被我们用得最多的当数<strong>key-value</strong>存储，当然还有其他的文档型的、列存储、图型数据库、xml数据库等。</p>

<h3 id='why_nosql'>Why NoSQL?</h3>

<p>随着互联网web2.0网站的兴起，传统的关系型数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如：</p>

<h4 id='id15'>对数据库高并发读写的需求</h4>

<p>web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。<strong>关系型数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO 就已经无法承受了</strong>，其实对于普通的BBS网站，往往也存在对高并发写请求的需求。</p>

<h4 id='id16'>对海量数据的高效率存储和访问的需求</h4>

<p>对于大型的SNS网站，每天用户产生海量的用户动态信息，以国外的Friend feed为例，一个月就达到了2.5亿条用户动态，<strong>对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的</strong>。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。</p>

<h4 id='id17'>对数据库的高可扩展性和高可用性的需求</h4>

<p>在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，可是停机维护随之带来的就是公司收入的减少</p>

<p>基于以上三点，NoSQL在现在越来越流行。</p>

<h2 id='why_mongodb'>Why Mongodb?</h2>

<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。<strong>他支持的数据结构非常松散，是类似json 的bjson格式，因此可以存储比较复杂的数据类型</strong>。MongoDB最大的特点是他<strong>支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引</strong>。它是一个面向集合的,模式自由的文档型数据库。</p>

<p>ok，既然MongoDB如此神奇，那么我们该怎么安装和使用他呢？下篇blog继续介绍。</p></div>
    </article>
  </section>
  
  <div class="pagination">
      <ul>
        <li><a href="/archive.html">归档</a></li>
        <li class="prev"><a href='/page2'>下一页 &rarr;</a></li>
      </ul>
  </div>
  </div>

  <aside class="span4">

    <section>
    <h4>最近发表</h4>
    <ul id="recent_posts">
      <li class="post">
        <a href="/linux/2013/09/22/mongodb-mmp">Mongodb 学习整理之内存映射机制</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/21/icap">ICAP RFC3507 部分章节翻译</a>
      </li>
      <li class="post">
        <a href="/blog/2013/09/20/alibaba">阿里巴巴面试总结</a>
      </li>
      <li class="post">
        <a href="/linux/2013/07/15/mongodb-install">Mongodb 学习整理之安装</a>
      </li>
      <li class="post">
        <a href="/linux/2013/07/09/mongodb-introduce">Mongodb 学习整理之介绍</a>
      </li>
      <li class="post">
        <a href="/linux/2013/06/23/hostapd">利用Hostapd搭建无线wifi</a>
      </li>
      <li class="post">
        <a href="/blog/2013/05/23/microsoft_test">2013微软暑期实习笔试错题、疑题整理</a>
      </li>
      <li class="post">
        <a href="/linux/2013/05/01/fluentd">fluentd插件开发</a>
      </li>
      <li class="post">
        <a href="/linux/2013/04/23/mongodb">Mongodb的备份与恢复</a>
      </li>
      <li class="post">
        <a href="/linux/2013/03/05/tplink">TL-WN822N TL-WN722N linux安装驱动</a>
      </li>
    </ul>
    </section>
    
  
    <h4>分类</h4>
    <ul class="tag_box">
      
      


  
     
    	<li><a href="/categories.html#blog-ref">
    		blog <span>4</span>
    	</a></li>
     
    	<li><a href="/categories.html#algorithm-ref">
    		algorithm <span>8</span>
    	</a></li>
     
    	<li><a href="/categories.html#link-ref">
    		link <span>2</span>
    	</a></li>
     
    	<li><a href="/categories.html#btree-ref">
    		btree <span>3</span>
    	</a></li>
     
    	<li><a href="/categories.html#vim-ref">
    		vim <span>1</span>
    	</a></li>
     
    	<li><a href="/categories.html#linux-ref">
    		linux <span>11</span>
    	</a></li>
     
    	<li><a href="/categories.html#c-ref">
    		c <span>2</span>
    	</a></li>
    
  


    </ul>
  

  </aside>
</div>

  </div>
</div>


      </div>

      <footer>
        <p>&copy; tinyfisher 2013 
          基于 <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          和 <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a> 构建
        </p>
      </footer>

    </div> <!-- /container -->
    
  </body>
</html>

