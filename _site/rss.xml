<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>tinyfisher blog</title>
        <description>tinyfisher blog - tinyfisher</description>
        <link>http://tinyfisher.github.com</link>
        <link>http://tinyfisher.github.com</link>
        <lastBuildDate>2014-01-30T15:05:43+08:00</lastBuildDate>
        <pubDate>2014-01-30T15:05:43+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>2013-2014</title>
                <description>&lt;p&gt;今天是13年农历腊月二十九，明天就是大年三十了，本命年过得真快。今年对我来说，不同寻常，除了是本命年，还因为今年发生了很多事情：历时半年的求职，爷爷的去世，第一份实习。这些事情都让我对自己有了更清楚的认识，让我变得更加成熟，尤其是求职。这是我第一次写总结，bolg的好处在于：多年之后，回看这些文章，会觉得当年的自己那么幼稚，那么年轻。&lt;/p&gt;

&lt;h2 id='id29'&gt;求职&lt;/h2&gt;

&lt;p&gt;轰轰烈烈的求职季持续了半年，整个求职的过程对我影响非常大，从一开始的跃跃欲试，到0 offer的焦虑，到选offer的纠结，再到违约，求职的所有过程都印象深刻。到后来，求职不仅仅是找工作这么简单，我在反复的问自己：你到底想要什么？&lt;br /&gt;先来说说最终结果吧：&lt;br /&gt;签约：中行总行信息中心&lt;br /&gt;offer list：江苏联通，华为，中兴，江苏电信，中清龙图，江苏移动，中行总行信息中心&lt;br /&gt;详细战绩：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;阿里：笔试过，面试跪  
创新工场：笔试过，一面过，二面跪  
暴风影音：笔试跪  
SAP：笔试跪  
优酷土豆：笔试跪  
数码视讯：笔试跪  
IBM Linux组：电面跪  
雅虎：笔试跪  
微软：笔试跪  
瑞晟：面试跪  
中清龙图：笔试过，一面过，二面过，offer 拒  
大众点评：笔试过，电面跪  
网易：笔试跪  
4399：一面过，二面过，三面跪  
百度：笔试过，面试跪  
腾讯：笔试过，一面过，二面跪  
华为：笔试过，一面过，二面过，offer，拒  
美团：笔试过，一面过，二面跪  
去哪：笔试跪  
渣打科营：电面跪  
江苏电信：一面过，二面过，offer，签约，违约  
绿盟：笔试跪  
完美世界：笔试跪  
江苏联通：笔试过，面试过，offer，拒  
中兴：一面过，二面过，offer 拒  
思科：笔试跪  
通联数据：一面过，二面过，拒三面  
江苏移动：笔试过，一面过，二面过，offer，拒  
农行苏州分行：笔试跪  
上交所：笔试跪  
人寿数据中心：笔试过，拒面试  
中国银行总行信息中心：笔试过，面试过，offer，签约  
中国银行软件中心：笔试过，面试过，体检拒  
中国人民银行清算总中心：笔试过，面试跪  
江苏国税局：国考跪  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里记录的都是参加笔试的，那些简历挂了，或者时间冲突去不了的都不在列表内。可以看到，互联网几乎全军覆没，充分体现了技术渣的本色。&lt;/p&gt;

&lt;h3 id='id30'&gt;起&lt;/h3&gt;

&lt;p&gt;去年开学之后，就开始陆陆续续的准备找工作的事宜，那时候很焦虑，不知道自己能否找到一份不错的工作，所以从三、四月份就开始准备计算机基础知识，《编程之美》，《剑指offer》。&lt;br /&gt;8月份的时候，参加了微软、腾讯、阿里的暑期实习生笔试，全跪。我才意识到我准备的有多渣，回去之后继续疯狂看计算机基础知识，《编程之美》，《剑指offer》。&lt;br /&gt;同时开始准备简历，从技术类到国企类，从一页到两页，从中文到英文，各种简历都在准备中，简历陆陆续续修改了不知改了多少次，每一句话都需要斟酌，各种细节都值得注意。比如：邮箱从163的换成了foxmail的，简历从一页半变成了一页版和两页版，博客地址从csdn换成了github的，电话从一串数字变成了4-3-4的格式，针对不同公司增改信息等等，都只为体现两个字——专业。&lt;br /&gt;一个月之后，求职第一波——互联网拉开了序幕，我也觉得我准备的不错了，踌躇满志，决定怒砍xx个offer。&lt;/p&gt;

&lt;h3 id='id31'&gt;承&lt;/h3&gt;

&lt;p&gt;时间来到9月份，各大互联网公司开始秋季招聘，于是我开始疯狂的投简历，饥不择食，每天刷新论坛，大街，应届生，只要有公司招，我就投，甚至一些没听过、不了解的公司。投简历是很无聊的，网投都需要填写一堆重复的信息，还有的公司的投递系统做的很烂，投个简历需要半个小时，九月份基本都是在重复投简历当中度过的，我没有统计过我投了多少，大约在100+吧。&lt;br /&gt;月底的时候，父亲打电话让我速回家，爷爷可能不行了。我当时懵了，没想到病情恶化的这么快，同时疯狂的刷着票，国庆的票真tm难买，终于在发车前2个小时刷了一张票，立马收拾东西赶回家。&lt;br /&gt;终究还是没能赶上，到家的时候，爷爷已经去世了9个小时，家人沉浸在悲痛的气氛中，当得知爷爷临终前还在呼喊我的名字的时候，我再也忍不住，眼泪狂飙，我想这是我人生最大的遗憾，没有之一。葬礼持续了三天，送走了各位亲朋，稍作几天的休息，我便踏上了回京的旅程，真正的战斗即将开始。&lt;br /&gt;由于互联网公司对简历的要求不像国企那么严，所以基本都能拿到笔试机会，俗称“海笔”。互联网的笔试无非都是那些，语言，算法，网络，系统，编程；准备充分加抱团加手机，一般都能过。&lt;br /&gt;真正的挑战是面试，互联网的面试一般都是：聊项目，写代码。其中聊项目只是热场，决定你能否通过的是你写的代码。编程题有的是《剑指offer》和《编程之美》上的，有的是我没有见过的，所以出我见过的题，我都能通过面试，出我没见过的题，必挂，无须挣扎，说明我对算法掌握的很烂，而且我对编程其实没有丝毫的兴趣。有意思的是，BAT三家互联网巨头的面试，我都挂在了二面，离offer只有一步之遥，很是无奈。&lt;br /&gt;十月是笔试面试宣讲集中爆发的一个月，这个月基本都是在赶场子，每天安排的都很满，我记得最恐怖的一天赶六场，都是前期海投惹的，当时应该有针对性的投。来一张当时google calender的截图吧，可见十月的忙碌。&lt;/p&gt;

&lt;p&gt;&lt;img alt='google' src='/assets/themes/images/google.png' /&gt;&lt;/p&gt;

&lt;p&gt;然而，十月快结束了，我依然是0 offer，这时候大牛们已经拿到几个offer开始比较了，而我准备时间最多的互联网已经基本结束，我开始不淡定了，前期准备怒砍xx个offer的想法是多么可笑。&lt;/p&gt;

&lt;h3 id='id32'&gt;转&lt;/h3&gt;

&lt;p&gt;十一月，互联网基本结束，国企运营商银行新一波已经到来，国企和互联网完全是两条路子，无论是简历筛选还是笔试面试，过互联网的简历比较容易，而国企过简历就没那么简单了，由于本科非211,985，在一些看重学历的国企中，简历基本无法通过。比较对口就只剩运营商了。&lt;br /&gt;由于是邮电院校，各大运营商会来北邮宣讲，完了会有提前批的招聘，也算是邮电学校的福利了。之前已经确定不留北京，工作往长三角方向找，所以三家运营商我都是投的江苏的。&lt;br /&gt;如果说互联网面试最难的是写代码，而国企面试最难的就是群面了，还记得本科找工作时群面从头到尾没说一句话的尴尬，所以我基本每周有空都会去看研会组织的“模拟群面”，不得不说，研会的这个活动很靠谱，请了一些专业的hr，以实战的形式给我们讲解群面技巧，我从中也学到了不少，为后面的实际群面打下基础。&lt;br /&gt;我还记得那个晚上，我正参加完面试回学校，手机响了，对面说：“请问是xxx吗，这里是江苏联通人力资源部。。。”，我知道第一个offer来了，我压着兴奋的心情通完电话，那天晚上心情特别好，终于告别0 offer的尴尬了，虽然联通不是很理想的选择，但这个offer犹如选中送碳，给了我极大的鼓舞，也是我开始offer收割的转折点，这里向联通表示感谢。&lt;br /&gt;之后，电信和移动也纷纷开始了招聘，由于有了保底的offer，以及前期群面的积累，我很顺利的拿到了电信和移动的offer，之前一直担心的群面，现在看来根本没有那么难，只要你敢于说出自己的想法，跟着团队的大方向走，适时提出自己的观点，不要阻碍整个讨论的进行，群面都能过，在三次群面中，我两次扮演了leader的角色，能够让大家跟着自己的思路去讨论，是很有成就感的事情。&lt;br /&gt;没有offer的时候很焦虑，而有offer的时候一样很蛋疼，因为单位会逼签，华为和中兴逼签的时候，我果断拒了，因为这些都是byr用来保底的offer，每年华为都招非常多的应届生，今年华为涨薪了，但华为和我向往的生活相去甚远，所以还是拒了。&lt;br /&gt;但是当电信逼签的时候，我很纠结，因为当时移动面试过去快两个星期了还没有消息，移动毕竟是三大运营商的大哥，工资待遇也是第一，4G也是风生水起，但是电信已经拖不起了，我和家里商量了一下，父亲说，你签，家里和电信那边有些关系，到时候违约不会难为你。于是我和电信签了三方，结果过了2天，移动通知体检，无语。&lt;br /&gt;十一月底了，我看后面除了银行也没什么单位招聘了，但进银行基本是小概率事件，所以基本打算毕业回老家的运营商了，于是打算和帝都告别，找了一份新浪的实习，没想到还能去新浪的年会，吃金钱豹，抽奖（虽然毛都没中），当然这些都是后话了。&lt;/p&gt;

&lt;h3 id='id33'&gt;合&lt;/h3&gt;

&lt;p&gt;万万没想到，当我基本准备毕业回家的时候，中行和人行分别通知我笔试过了，尼玛中行的笔试是连蒙带C做的，这也能过，我一定是交狗屎运了。&lt;br /&gt;既然过了笔试，那就好好准备面试吧，毕竟这是最后的两场面试了，中行的面试分好几批，从论坛上得知了一些消息，特意去准备了一些相关内容。后来面试比较顺利，中行给我发offer了，兴奋之余，又有一个问题让我很苦恼：&lt;br /&gt;&lt;strong&gt;上海or老家&lt;/strong&gt;&lt;br /&gt;我只有几天的时间考虑，中行规定要在5天内向原单位提出解约申请，之后便可等你到三月份拿到新三方，而且不用交押金，这里赞一个，非常人性化。&lt;br /&gt;家人意见：follow your heart。回家，家里找关系，以后在运营商里混，前途明朗。去上海，家里卖掉一套房，交首付。这里向爸妈表示感谢！&lt;br /&gt;tomsawyer：这个世界我还没看够。&lt;br /&gt;cowboy：你还年轻。&lt;br /&gt;罗胖：见识决定命运。&lt;a href='http://v.youku.com/v_show/id_XNDk0MDU3NzIw.html'&gt;《拒绝逃离北上广，见识决定命运》&lt;/a&gt;，这是《罗辑思维》第二期节目，当时的罗胖说的还略显青涩。&lt;br /&gt;最终，我还是和电信解约，准备去中行了，至此，我的半年的求职生涯画上终点。&lt;/p&gt;

&lt;h2 id='id34'&gt;致谢&lt;/h2&gt;

&lt;p&gt;求职是一件很苦闷的事，无论是身体还是精神，但他也会让你对自己有一个更加清楚的认识，通过不断的面试沟通，你会越来越清楚自己有什么，适合干什么。这里向大伙表示感谢：&lt;br /&gt;1.感谢父母，感谢你们创造的条件，让我可以有充分的选择余地。&lt;br /&gt;2.感谢小伙伴，带投简历，笔试抱团，面经分享，消息互通，我不是一个人在战斗。 &lt;br /&gt;3.感谢自己，感谢自己那么拼命的去求职，感谢自己勇敢得做出每一个选择，多年之后我一定会感谢今天那么努力的自己。&lt;/p&gt;

&lt;h2 id='it'&gt;关于银行IT&lt;/h2&gt;

&lt;p&gt;应届生第一份的工作应该说比较重要，关于银行IT，论坛上有两种看法：一种是“金融高富帅”，无脑入，另一种是sze为代表的银行IT没地位没发展。这里说说我的看法：工作没有好坏，只有适合不适合，除了二代，基本没有钱多活少离家近，位高权重责任轻的工作，所以选择一份工作最重要的是看你是否适合他。那么什么样的人适合去银行IT？&lt;br /&gt;这篇&lt;a href='http://blog.csdn.net/koudaidai/article/details/7909019'&gt;《还原一个真实的银行待遇》&lt;/a&gt;写得不错，应该是北邮师兄写的，这里面提到：&lt;br /&gt;什么样的人适合去银行的科技岗位？我觉得是比较中庸的人，技术一般，沟通一般，野心一般的人。毕竟银行的软开，总体来说，待遇还是比一般的计算机公司好，而且相对稳定一些。对于不是牛人来说，银行的软开科技部也是一个不错的选择。而且软开大部分户口还是有保证的，对于在北京混的人来说，没有户口还是麻烦。&lt;br /&gt;所以我这种中庸的人只能去银行IT了。&lt;/p&gt;

&lt;h2 id='id35'&gt;中行&lt;/h2&gt;

&lt;p&gt;既然最终签约了中行，这里写个笔经面经，供大家参考吧：&lt;br /&gt;&lt;strong&gt;简历&lt;/strong&gt;&lt;br /&gt;过银行的简历比较难，尤其是我这种本科非211,985的，五大行只过了农行苏分和中行，不过论坛上也有双985+各种证书的挂了的，有人说银行简历是随机的，有人说银行只要长得好看的。。。所以过银行简历除了好好准备外，rp也是非常重要的。&lt;br /&gt;&lt;strong&gt;笔试&lt;/strong&gt;&lt;br /&gt;银行笔试一般都是机试，分为四个部分：英语，行测，金融知识和专业知识。每个部分1个小时，中间无休息时间，一做4个小时，全程无尿点。&lt;br /&gt;英语类似于托业，难度介于四六级，题量大，60min做100道，提高速度是关键。&lt;br /&gt;行测难度和公务员差不多。&lt;br /&gt;金融知识，连蒙带C，全是蒙的，大家想进银行IT的可以稍微准备一下，里面有几道中行的基础题，提前可以看一看。&lt;br /&gt;专业知识：数据库，软件测试，软件工程考得比较多。&lt;br /&gt;过笔试的运气成分也很大。。。&lt;br /&gt;&lt;strong&gt;面试&lt;/strong&gt;&lt;br /&gt;中行面试先做专业笔试，其实就是类似于公务员申论的题，半个小小时结合材料写文章，我抽到的是“结合光大乌龙事件，谈谈你对银行科技工作的理解。”，做完之后抽签决定面试顺序，面试是7V1，内容是结构化面试。&lt;br /&gt;面试有压力面的成分，我进去自我介绍才说了几句，中间的boss就说：“简历上写的就不要说了，你只有2min，好好把握。”，所以千万不能慌，底气要足，不能被7张冰冷的面孔吓尿，用自己的气势hold住全场。回答问题的时候，边说边想，随机应变，不能出现长时间的沉默，这样会很尴尬，而且你的压力会越来越大。&lt;br /&gt;&lt;strong&gt;体检&lt;/strong&gt;&lt;br /&gt;银行体检果然高大上，是我体检最全最专业的一次，男外还有惊喜。。。&lt;br /&gt;&lt;strong&gt;签约&lt;/strong&gt;&lt;br /&gt;这里我得赞一下中行，非常人性化，只需签一个资格保留协议，中行就会等你拿到新三方，所以大可先签一个保底。资格保留协议如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;尊敬的XXX同学：
根据今日签约会上沟通的情况，我们为您保留了录用资格，希望您务必尽快与原签约单位办理解约手续并告知我们。您可以通过以下任一形式让我们知晓您已经与原单位办理解约或提出办理解约：
1、将原签约单位开具的解约证明、解约函、违约金收据等材料的扫描件发送至本邮箱；
2、将学校就业指导中心或院系就业办开具的解约证明、办理解约手续的相关材料的扫描件发送至本邮箱；
3、原签约单位或学校不能出具材料的，请通过电子邮件形式向该单位办公邮箱或HR工作人员办公邮箱正式发信申请解约，并将此邮件抄送本邮箱；
4、原签约单位或其HR工作人员不具有办公邮箱的，请提供该单位人事工作人员的姓名、职务、联系方式（办公电话或办公邮箱），供我们核实解约情况。
以上材料或信息，请务必在1月15日前向我行提供。
如您可以直接从原单位手中获取三方协议，并可以和我行签约的（请与学校院系或就业指导中心联系核实，据我们了解部分院校在发放三方协议时会进行登记，如您当时登记的是原签约单位，后直接凭该三方与我行签约，学校将不予承认），请向我们发送邮件或致电联系三方签订事宜。
联系电话：xxxxxx
如果您经考虑，决定不与我行签订就业协议的，也请通过邮件告知我们。
谢谢！&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/blog/2014/01/29/summary</link>
                <guid>http://tinyfisher.github.com/blog/2014/01/29/summary</guid>
                <pubDate>2014-01-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>新浪实习</title>
                <description>&lt;p&gt;今天第一天去新浪实习，吐槽下实验室，一直不让实习，太黑。最近比较闲，没啥面试，论文也差不多了，终于找到了人生第一份实习，也算是和北京告别的第一天。当年怀着无比向往的心情来到帝都，时间真快，一转眼就要离开了，从一开始不适应这里干燥的空气，鼻子出血，到现在已经习惯了这里的气侯，甚至雾霾，真要离开竟有一丝不舍，因为这里是北京，有着五彩斑阑的机会和无限的可能，有着无数年轻人的梦想。告别帝都从新浪实习开始吧。第一天，人工查看是否是垃圾邮件，编写python脚本自动发邮件进行测试，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import smtplib
from email.mime.text import MIMEText
mailto_list=[&amp;quot;yxh.8116836@163.com&amp;quot;,&amp;quot;tinyfisher@foxmail.com&amp;quot;] 
mail_host=&amp;quot;smtp.sina.cn&amp;quot;   
mail_user=&amp;quot;tinyfisherbupt&amp;quot; 
mail_pass=&amp;quot;yxh19890804&amp;quot;    
mail_postfix=&amp;quot;sina.com&amp;quot;    
def send_mail(to_list,sub,content):    
    me=mail_user+&amp;quot;&amp;lt;&amp;quot;+mail_user+&amp;quot;@&amp;quot;+mail_postfix+&amp;quot;&amp;gt;&amp;quot;
    msg = MIMEText(content)
    msg[&amp;#39;Subject&amp;#39;] = sub
    msg[&amp;#39;From&amp;#39;] = me
    msg[&amp;#39;To&amp;#39;] = &amp;quot;;&amp;quot;.join(to_list)
    try:
        s = smtplib.SMTP()
        s.connect(mail_host)
        s.login(mail_user,mail_pass) 
        s.sendmail(me, to_list, msg.as_string())
        s.close()
        return True
        except Exception, e:
        print str(e)
        return False
if __name__ == &amp;#39;__main__&amp;#39;:
    if send_mail(mailto_list,&amp;quot;subject&amp;quot;,&amp;quot;content&amp;quot;):
        print &amp;quot;send success&amp;quot;
    else:
        print &amp;quot;send fail&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是，你的邮箱需要开启smtp/pop3，登录到你的web邮箱，在里面的设置里开启&lt;/strong&gt;&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/blog/2013/12/16/sina</link>
                <guid>http://tinyfisher.github.com/blog/2013/12/16/sina</guid>
                <pubDate>2013-12-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>一道有趣的面试题</title>
                <description>&lt;h4 id='60910120131'&gt;题目：给你两个骰子，每个骰子的6个面都是空的，现在要你把0~9这10个数填到这两个骰子的12个空白面上（数字可以重复），使得能够用这两个骰子表示一个月的号数：从01到31（出自中清龙图）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;提示：这两个骰子中的数既可以表示十位，又可以表示个位&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思路：1.那就先看从01到09怎么填吧&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如两个骰子A,B；我首先在A中填0，在B中填1,2,3,4,5 此时，按照AB的摆放，可以表示01到05，我再在B中填0，A中填6,7,8,9，此时按照BA的摆放，可以表示06到09，这时A六个面：0,6,7,8,9，空；B中六个面：1,2,3,4,5,0&lt;br /&gt;此时A中还剩一个空位，B已经满。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.再来看10~19怎么填&lt;/strong&gt;&lt;br /&gt;因为B中有1，按照BA的摆放，可以表示10,16,17,18,19；要表示其他的必须在A中存放1，此时A：0,6,7,8,9,1；按照AB摆放，可以表示：11,12,13,14,15,10；&lt;br /&gt;此时A，B都满了，其中A:0,6,7,8,9,1；B：1,2,3,4,5,0；&lt;br /&gt;&lt;strong&gt;3.再看20~29：&lt;/strong&gt;&lt;br /&gt;因为B中有2，按照BA摆放，可以表示：20,26,27,28,29,21；&lt;strong&gt;可A中已经满了，怎么表示其他的数呢？&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;面试官提示：如果A有7个面，你怎么做？&lt;/strong&gt;&lt;br /&gt;如果A有7个面，那我按照上面的思路，在A中再填2，此时A:0,6,7,8,9,1,2；按照AB的摆放可以表示20,21,22,23,24,25；至于30,31是没有问题的。&lt;br /&gt;&lt;strong&gt;现在的问题就是：2个骰子12个面，如果13个面，问题解决，但少了一个面，能否将某些数字压缩？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面试官提示：首先看看那些数字是必须存在于两个骰子？看看0,1,2是否必须存在？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先1和2肯定存在，因为要表示11和22,0也是必须存在，若只有一个面有0，肯定不能表示01到09；&lt;br /&gt;ok，此时A:0,1,2；B:0,1,2；那么还剩下6个面和7个数：3,4,5,6,7,8,9，&lt;strong&gt;现在的问题是：怎么把这7个数压缩成六个？&lt;/strong&gt;&lt;br /&gt;我：“这不可能吧？”&lt;br /&gt;面试官：“我给你的是骰子，不是数组，想想有没有其他方法？”&lt;br /&gt;我：“我用刀切一个骰子，变成13个面”（囧）&lt;br /&gt;面试官：“我可没给你刀，骰子可以随意摆，再想想？”&lt;br /&gt;我：“难道是6跟9算一个？”&lt;br /&gt;面试官：“嗯，不错，想的还挺快。”&lt;/p&gt;

&lt;p&gt;有点脑经急转弯的意思，面试官后来说了他为什么出这道题：&lt;strong&gt;程序员在编代码的时候，可能会陷入思维定式，有时候我们的空间和时间有限，必须要提高程序的效率，还有就是代码的重用，6跟9倒一下就可以，代码中可重用的有很多，需要注意。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;总的来说，这道题还是非常有趣的，面试官是北邮师兄，通过一步步的沟通提示，完成这道题，感觉还是不错的，哈哈~&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/blog/2013/10/15/zqlt</link>
                <guid>http://tinyfisher.github.com/blog/2013/10/15/zqlt</guid>
                <pubDate>2013-10-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>面试算法题整理</title>
                <description>&lt;p&gt;最近面试跪了不少，都基本是跪在算法题上，现在把遇到的一些题目记录下来，方面以后复习&lt;/p&gt;

&lt;h4 id='10111001111000001100000014041'&gt;1.一个字符串只有0和1，如“110011110000”，找到这个串中的最长子串，使得子串的0和1个数相等，比如：1000&lt;code&gt;01011100&lt;/code&gt;0001，阴影的部分有4个0、4个1（出自美团）&lt;/h4&gt;

&lt;p&gt;思路：最简单的想法就是遍历所有的子串，之后判断该子串是否满足条件N^2子串，每个子串扫一遍判断0、1是否出现的次数相等，复杂度为O(N^3)，稍加思考就会发现， &lt;strong&gt;如果一个长度为n的子串满足条件，加么这n个元素的和加起来一定=(n/2)&lt;/strong&gt;，这样在循环的过程中，增量加就可以了，不需要每个子串从头计算，复杂度降为O(N^2);伪码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int maxlen = 0, sum = 0, currlen = 0;
for(int i = 0; i &amp;lt; N; ++i)
{
    sum = 0;
    for(int j = i; j &amp;lt; N; ++j)
    {
        currlen = j - i + 1;
        sum += int(A[j]);
        if(currlen%2 == 0 &amp;amp;&amp;amp; sum == currlen/2 &amp;amp;&amp;amp; currlen &amp;gt; maxlen)
            maxlen = currlen;
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有没有办法进一步降低算法的复杂度呢？&lt;/p&gt;

&lt;p&gt;面试官说有这样一种巧妙的解法：定义一个数据B&lt;span&gt;N&lt;/span&gt;， B&lt;span&gt;i&lt;/span&gt;表示从A&lt;span&gt;0&amp;#8230;i&lt;/span&gt;中 num_of_0 - num_of_1，0的个数与1的个数的差，那么如果A&lt;span&gt;i&lt;/span&gt; ~ A&lt;span&gt;j&lt;/span&gt;（A&lt;span&gt;i&lt;/span&gt;,A&lt;span&gt;j&lt;/span&gt;选一个包含）是符合条件的子串，一定有 B&lt;span&gt;i&lt;/span&gt; == B&lt;span&gt;j&lt;/span&gt;，因为中间的部分0、1个数相等，相减等于0。 只需要扫一遍A&lt;span&gt;N&lt;/span&gt;就能把B&lt;span&gt;N&lt;/span&gt;构造出来了。&lt;strong&gt;这样问题就转换成了求距离最远的一对数&lt;/strong&gt;，使得B&lt;span&gt;i&lt;/span&gt; == B&lt;span&gt;j&lt;/span&gt;，因为B&lt;span&gt;i&lt;/span&gt;的范围一定是&lt;span&gt;-N,N&lt;/span&gt;，-N到N的范围都存起来，建一个-N到N的hash表，index就是-N到N，value就是index相等的两个数的最长距离，这样每扫到B&lt;span&gt;i&lt;/span&gt;，如果hash表里的值还不存在，填i，若已经存在，填i和里面值得差，即为当前长度，需要更新最大长度这个值。其实代码真的非常简单，一个循环就搞定了，这就是算法和思考的乐趣:)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int A[N],B[N];
int num[2*N + 1];
int count[2] = {0,0}, maxlen = 0, currlen = 0;
memset(C, 2*N, -1);
for(int i = 0; i &amp;lt; N; ++i)
{
   count[ int(A[i]) ] += 1;
   B[i] = count[1] - count[0];
   if( num[ B[i] + N ] == -1)//尚不存在，B的下标是差，值是A的下标 
       num[ B[i] + N ] = i; 
   else//already exist
   {
       currlen = i - num[ B[i] + N ] + 1; //num[ B[i] + N ]是B[i]已存在的下标
       if(currlen &amp;gt; maxlen)
           maxlen = currlen;
   }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='2a1b2c4abbcccc'&gt;2.编程实现把一个字符串从“a1b2c4”转成“abbcccc”，不准申请新的内存，原字符串可以认为后面的空间足够大（出自美团）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：统计所有的数字之和何以得到最终字符串的长度，然后利用两个指针str1指向原字符串尾，str2指向新字符串尾，记录str1的数字n，和前面的字符m，str2从后向前写n个m，直到str1指向第一个字符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：可能会出现覆盖问题，例如“a1b2c3”转成“abbccc”，原字符串和新字符串长度都是6，按照我上面的算法，第一步之后字符串会变成“a1bccc”，这是我无法得到b的次数2，因为2被c覆盖了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么会覆盖？&lt;/strong&gt;&lt;br /&gt;原因在“a1”上，“a1”最后要变成“a”，原字符串多占了一位，导致后面的出现覆盖，所以对于所有的“X1”要进行预处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么处理&lt;/strong&gt;？&lt;br /&gt;遍历一遍字符串，每遇到“1”，把后面的字符串向前移动一位，例如“a1b2c3”变成“ab2c3”，这个时候，再对“ab2c3”进行我之前的处理，第一步变成“ab2ccc”，是没有问题的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：因为把1去掉之后，原字符串的格式发生了变化，遍历的时候需要注意判断一下。&lt;/p&gt;

&lt;h4 id='33333123111'&gt;3.整数分割，比如给定一整数3，其有如下情况：3=3,3=1+2,3=1+1+1,求一个数的所有分割组合（出自创新工场行云）&lt;/h4&gt;

&lt;p&gt;n=m1+m2+&amp;#8230;+mi; （其中mi为正整数，并且1 &amp;lt;= mi &amp;lt;= n），则{m1,m2,&amp;#8230;,mi}为n的一个划分。&lt;/p&gt;

&lt;p&gt;如果{m1,m2,&amp;#8230;,mi}中的最大值不超过m，即max(m1,m2,&amp;#8230;,mi)&amp;lt;=m，则称它属于n的一个m划分。这里我们记n的m划分的个数为f(n,m);&lt;/p&gt;

&lt;p&gt;例如n=4时，他有5个划分，{4},{3,1},{2,2},{2,1,1},{1,1,1,1};&lt;/p&gt;

&lt;p&gt;该问题是求出n的所有划分个数，即f(n, n)。下面我们考虑求f(n,m)的方法;&lt;br /&gt;根据n和m的关系，考虑以下几种情况：&lt;/p&gt;

&lt;p&gt;(1) 当n=1时，不论m的值为多少（m&amp;gt;0)，只有一种划分即{1};&lt;/p&gt;

&lt;p&gt;(2) 当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,&amp;#8230;,1};&lt;/p&gt;

&lt;p&gt;(3) 当n=m时，根据划分中是否包含n，可以分为两种情况：&lt;/p&gt;

&lt;p&gt;(a).划分中包含n的情况，只有一个即{n}；&lt;/p&gt;

&lt;p&gt;(b).划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。&lt;/p&gt;

&lt;p&gt;因此 当n=m时，f(n,n) =1 + f(n,n-1);&lt;/p&gt;

&lt;p&gt;(4) 当n &amp;lt; m时，由于划分中不可能出现负数，因此就相当于f(n,n);&lt;/p&gt;

&lt;p&gt;(5) 当n &amp;gt; m时，根据划分中是否包含最大值m，可以分为两种情况：&lt;/p&gt;

&lt;p&gt;(a).划分中包含m的情况，即{m, {x1,x2,&amp;#8230;xi}}, 其中{x1,x2,&amp;#8230; xi} 的和为n-m，因此这种情况下为f(n-m,m)&lt;/p&gt;

&lt;p&gt;(b).划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);&lt;/p&gt;

&lt;p&gt;因此，当n &amp;gt; m时 f(n, m) = f(n-m, m)+f(n,m-1);&lt;/p&gt;

&lt;p&gt;综上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f(n,m)=1;(n=1||m=1)  

f(n,m)=f(n,n);(n&amp;lt;m)  

f(n,m)=1+ f(n, m-1);(n=m)  

f(n,m)=f(n-m,m)+f(n,m-1); (n&amp;gt;m)  &lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/algorithm/2013/10/14/interview</link>
                <guid>http://tinyfisher.github.com/algorithm/2013/10/14/interview</guid>
                <pubDate>2013-10-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>阿里巴巴二面总结</title>
                <description>&lt;p&gt;二面面试官澄观，一看就很牛逼的样子，年龄也比一面的易统大一些，拿着我的简历，顺手拿了几个零食把我带到大厅，开始面试&lt;br /&gt;&lt;strong&gt;1.你擅长什么？&lt;/strong&gt;&lt;br /&gt;我去，突出一个防不胜防，没有自我介绍，也不问项目，简历扫了一眼，扔一边。&lt;br /&gt;这个问题不好答，我怕给自己挖一个坑，我就说linux用的还行，他说哪方面，我说系统使用方面，常用命令比较熟，他就问了一个问题，把一个文件夹里的.cpp文件中的BUPT换成alibaba，怎么实现？&lt;br /&gt;sed -i &amp;#8220;s/BUPT/alibaba/g&amp;#8221; ./*.cpp&lt;/p&gt;

&lt;p&gt;个人感觉这个问题就是坑啊，如果不是特别擅长，很容易被问住，好比让你在简历上选填你精通什么，然后问到你挂。&lt;br /&gt;&lt;strong&gt;2.学生期间有什么可以展示的，不限技术&lt;/strong&gt;&lt;br /&gt;随意发挥&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.有用过多线程或者多进程么？在什么情况下用的？两者有什么区别&lt;/strong&gt;&lt;br /&gt;项目中有个监听线程，监听到3G网卡掉线，自动重连。&lt;br /&gt;多线程好处：节约资源，并发快&lt;br /&gt;多进程好处：安全，即使子进程挂了，父进程不会挂 &lt;br /&gt;多线程缺点：不安全，一个线程挂掉，整个进程挂了&lt;br /&gt;多进程缺点：资源占用比较多，并发性不如线程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.apache知道吗？看过源码吗？是多进程还是多线程的？http请求方法有哪些？服务器怎么知道用户登陆过？&lt;/strong&gt;&lt;br /&gt;知道，没看过，猜测是多进程的，GET，POST，（其余不常用，没怎么记，面试官貌似不满意）。&lt;br /&gt;通过sessionid，用户请求时，服务器生成一个sessionid传给客户端，客户端用cookie保存sessionid，然后登陆的时候通过cookie把sessionid再发送给服务端。（大致这个意思，面试官大致满意）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.二叉树求深度，不准递归，树是只读的&lt;/strong&gt;&lt;br /&gt;我的思路：用队列按层遍历，每一层加一，面试官说：你怎么知道这一层遍历完了？这里想了很久，说再用一个栈保存结果，栈为空的时候，这层完了，此时加一，面试官说：行是行，但浪费空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.求一千亿个数的中位数，这些数无序&lt;/strong&gt;&lt;br /&gt;我的思路：hash%1000，分成小文件，求出小文件的最大和最小值，然后按照这个区间，使得这1000个小文件按照顺序排列，中位数在中间的小文件里，面试官说：不一定。发现是的，我说那我记录每个文件的个数，根据这个元素个数定位到小文件，对这个小文件排序，根据偏移量，找到中位数，面试官说对。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：深入再深入，必须能有一样能征服面试官的，要有亮点，这点我还得加强，本来想说项目，直接被无视。算法题注定是难的，千万别放弃，展示出想要解决他的勇气，可以问面试官要提示，互动的解决这个问题，一旦放弃，这轮面试也就挂了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于session和cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为什么会有cookie和session呢,大家都知道，http是无状态的协议（&lt;strong&gt;无状态是指，当浏览器发送请求给服务器的时候，服务器响应，但是同一个浏览器再发送请求给服务器的时候，他会响应，但是他不知道你就是刚才那个浏览器，简单地说，就是服务器不会去记得你，所以是无状态协议。&lt;/strong&gt;），客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能实现网上商店中的购物车呢？&lt;/p&gt;

&lt;p&gt;session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现，系统会创造一个名为JSESSIONID的输出cookie，我们叫做session cookie,以区别persistent cookies,也就是我们通常所说的cookie,注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，这也就是我们刚才看到的JSESSIONID，我们通常情是看不到JSESSIONID的，但是当我们把浏览器的cookie禁止后，WEB服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到sessionid=KWJHUG6JJM65HS2K6之类的字符串。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把sessionid传递回服务器。&lt;/p&gt;

&lt;p&gt;Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从：&lt;span&gt;系统盘&lt;/span&gt;:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于二叉树求深度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;思路：先层次遍历一遍找出最后一个节点，然后目的变为求这个节点的深度。然后我们用循环一层一层找到它的上一层，找到一次，深度加1，最终可以得到二叉树的深度。不需要栈了。&lt;br /&gt;例如下面的树：&lt;br /&gt;&lt;img alt='hello' src='/assets/themes/images/btree.jpg' /&gt; &lt;br /&gt;首先按层遍历获得最后一个元素J，然后从根再次按层遍历找到他的父节点E，此时深度+1，再从头按层遍历找到E的父节点B，此时深度加1，直到根节点为止&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于1000亿个数的中位数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的那种hash%1000的分割法有点问题，因为整数是有范围的，可按照整数范围分割文件，这样就不需要对每个文件排序，然后根据index偏移量找到小文件，只需对这个文件进行排序，取偏移量的数即可&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/blog/2013/09/26/alibaba2</link>
                <guid>http://tinyfisher.github.com/blog/2013/09/26/alibaba2</guid>
                <pubDate>2013-09-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>创新工场一面总结</title>
                <description>&lt;p&gt;跟hr约好了9点去面试，早上7点半起来，觉得不出意外能赶到，结果堵车了，急得要死，还好邮件里有hr的联系方式，提前打个电话说明了情况，对方表示没有关系，这下放心了。到了创新工场是大概9:10，迟到了10分钟左右，然后被hr mm带到一个叫手舞的玻璃房里，里面坐着面试官gg，谈吐穿着都非常儒雅，气氛不算很紧张。&lt;br /&gt;首先自我介绍，然后挑一个项目介绍，扯了扯，面试官开始直奔主题，写代码，早闻创新工场的面试就是这个样子，开始进入正题：&lt;br /&gt;&lt;strong&gt;1.快排，时间复杂度，怎么避免最坏情况的出现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;砍瓜切菜，至于优化在《算法导论》中看到过，partition的时候不是固定取末尾一个数，而是随机取，甚至可以随机取3个数，取这3个数的中位数作为key。面试官比较满意。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.一个整型无序数组，要求从中取三个数，要求：这三个数值递增，三个数在原数组中的下标值也递增，说思路&lt;/strong&gt;&lt;br /&gt;这题时间不够，没想出来。我的思路是：&lt;br /&gt;1.既然无序，那我排序试试看，结果发现如果排序势必会打乱下标的顺序，跟没排序其实没区别&lt;br /&gt;2.那么既然下标已经有序了，我就把所有符合下标递增的三元组找出来，看他们的值是否递增，面试官说：这个肯定可以，有没有优化的办法？&lt;br /&gt;卡住了，实在想不出来了，时间也到了，后来我就问面试官，这题怎么做，他告诉了我答案：&lt;br /&gt;举个例子：2,1,4,3,5&lt;br /&gt;面试官说我们只需要找到总共有多少个三元组，而不需要把他们找出来，充分利用数组下标已递增的特点，固定一个数，比如说4，那么以4为中值的三元组只需要从左边找到比4小的和右边找到比4大的即可。 哎，充分感觉智商不够用。不知道还能不能进二面&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：基础要牢，排序神马的基本是送分题，但也要深入研究下各个排序的特点，时间复杂度，最差情况，优化等等；至于算法题，还是搞题海战术吧，我这种智商的实在想不出来&lt;/strong&gt;&lt;br /&gt;今天收到二面通知，开心！&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/blog/2013/09/24/factory</link>
                <guid>http://tinyfisher.github.com/blog/2013/09/24/factory</guid>
                <pubDate>2013-09-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>IBM Linux组电面总结</title>
                <description>&lt;p&gt;下午四点多的突然接到IBM Linux电面，找了个安静的地方开始面试，对面GG比较友好，首先自我介绍，然后说了说项目，面试官还是很互动的，氛围比较轻松，还介绍了Linux组主要是做社区这一块，内核神马的。之后开始技术问题狂轰滥炸：&lt;/p&gt;

&lt;h4 id='1'&gt;&lt;strong&gt;1.大小端问题&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这个才看过，总结下：小端是指低地址在低字节，正常比较容易理解的就是小端；大端是指高位在低字节，低位在高字节（比较绕）。。。&lt;br /&gt;举个例子：0x1234，如果是小端，假设左边是内存高位，右边是内存低位，则小端存储如下：0x12,0x34；反之大端则是：0x34，0x12&lt;/p&gt;

&lt;h4 id='2fork'&gt;&lt;strong&gt;2.fork特点&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这个回答的还不错，fork会有两个返回值，返回值为0的为子进程，返回值不为0的为父进程，其数值含义是子进程的pid&lt;/p&gt;

&lt;h4 id='3'&gt;&lt;strong&gt;3.僵尸进程&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这个答错了，面试官问“是这样吗”之后，我就知道答错了，记混淆了。&lt;br /&gt;&lt;strong&gt;我的错误回答：父进程比子进程先结束，子进程由init进程管理，子进程成为僵尸进程&lt;/strong&gt;&lt;br /&gt;错误原因：我混淆了孤儿进程和僵尸进程的概念，我说的其实是孤儿进程。那么什么是僵尸进程呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于僵尸进程&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;1.僵尸进程是怎么产生的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束. 那么会不会因为父进程太忙来不及wait子进程,或者说不知道子进程什么时候结束,而丢失子进程结束时的状态信息呢? 不会。因为UNIX提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是: &lt;strong&gt;在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放&lt;/strong&gt;. 但这样就导致了问题,如果进程不调用wait / waitpid的话, 那么保留的那段信息就不会释放,其进程号就会一直被占用,但是系统所能使用的进程号是有限的,如果大量的产生僵死进程,将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害,应当避免。&lt;br /&gt;&lt;strong&gt;总结一下：一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就变成僵尸进程。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.僵尸进程的处理&lt;/strong&gt;&lt;br /&gt;任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为&lt;strong&gt;僵尸进程(Zombie)的数据结构&lt;/strong&gt;，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。&lt;/p&gt;

&lt;h4 id='4git'&gt;4.git&lt;/h4&gt;

&lt;p&gt;面试关看我的博客是在github上写的，于是又问了我git的问题，git rebase是干什么用的？&lt;br /&gt;我知道git add，commit，push，pull，checkout，reset，还真没用过rebase。。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先回顾一下git基本命令&lt;/strong&gt;&lt;br /&gt;git init 初始化代码仓库&lt;br /&gt;git add file 将工作目录里的file文件修改提交到本地暂存区&lt;br /&gt;git commit -m “commit” 将暂存区里的文件提交，备注“commit”，同时生成快照，就是一个hash值&lt;br /&gt;git checkout file 把file回滚到修改前的状态，注意这个针对还没有提交到本地暂存区的文件，即git add之前的文件 git reset HEAD file 把file从暂存区撤离，即git add 的反操作&lt;br /&gt;git revert &amp;lt;$id&amp;gt; 返回到commit id为&amp;lt;$id&amp;gt;的状态，本次也是一个动作，需要commit&lt;br /&gt;git reset &amp;#8211;hard HEAD~1 彻底回到倒数第二个commit，倒数第一个的commit会消失，文件内容也回到上个版本 git reset &amp;#8211;soft HEAD~1 将最后一个commit撤销，但文件内容没变，只需要重新commit即可 git diff 查看本地文件和暂存区文件差别 git log 查看commit记录&lt;br /&gt;git status 查看git文件暂存区状态 git pull 抓取远程仓库所有分支更新并合并到本地&lt;br /&gt;git push push所有分支到远程仓库 git push origin master 将本地主分支推到远程主分支&lt;br /&gt;git branch 显示所有分支&lt;br /&gt;git branch newbranch 创建分支&lt;br /&gt;git checkout branchname 切换到分支&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于git rebase&lt;/strong&gt;&lt;br /&gt;下面这篇&lt;a href='http://gitbook.liuhui998.com/4_2.html'&gt;blog&lt;/a&gt;写的比较不错，之前没有多人开发git的经验，还是挺难理解的.&lt;/p&gt;

&lt;h4 id='5kmallocvmalloc'&gt;&lt;strong&gt;5.kmalloc和vmalloc区别&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;没用过，不知道，查了下：&lt;br /&gt;kmalloc和vmalloc是分配的是内核的内存,malloc分配的是用户的内存&lt;/p&gt;

&lt;p&gt;kmalloc保证分配的内存在物理上是连续的,vmalloc保证的是在虚拟地址空间上的连续&lt;/p&gt;

&lt;p&gt;kmalloc能分配的大小有限,vmalloc和malloc能分配的大小相对较大&lt;/p&gt;

&lt;p&gt;内存只有在要被DMA访问的时候才需要物理上连续，即kmalloc&lt;/p&gt;

&lt;p&gt;kmalloc和 kfree管理内核段内分配的内存，这是真实地址已知的实际物理内存块。vmalloc和vfree是对内核使用的虚拟内存进行分配和释放&lt;/p&gt;

&lt;h4 id='6malloc'&gt;&lt;strong&gt;6.malloc调用的系统调用&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;不知道，查了下是brk，参见这篇&lt;a href='http://edsionte.com/techblog/archives/4174'&gt;blog&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='7fork'&gt;&lt;strong&gt;7.fork的优化&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;这个依然不知道，fork实现的时候并不是完全复制父进程的数据段和堆栈，而是采用了&lt;strong&gt;写时复制（copy-on-write）COW&lt;/strong&gt;技术。数据段和堆栈有父子进程共享，内核将他们的访问权限设为只读，父子进程中的任何一个试图修改这些区域，此时内核只为那些修改的区域的那块内存做一个副本，通常是一个page。&lt;/p&gt;

&lt;h4 id='8cc'&gt;8.C/C++遇到的坑&lt;/h4&gt;

&lt;p&gt;这个说了我之前遇到的链接错误，参见我的博文&lt;a href='http://tinyfisher.github.io/c/2012/11/23/makefile/'&gt;makefile 编写问题记录&lt;/a&gt;&lt;/p&gt;

&lt;h4 id='9ibmip'&gt;9.从IBM发ip包到北邮要查那些表，子网掩码干什么的？&lt;/h4&gt;

&lt;p&gt;这个知道，route表和arp表，子网掩码区分网络号和主机号，若网络号一致，表明在一个网段&lt;/p&gt;

&lt;h4 id='10gdb'&gt;10.gdb怎么调试段错误&lt;/h4&gt;

&lt;p&gt;没怎么用过，面试官说用backtrace&lt;/p&gt;

&lt;h4 id='11cpython'&gt;11.C和Python比较&lt;/h4&gt;

&lt;p&gt;水过，python方便，c执行效率高&lt;/p&gt;

&lt;h4 id='12'&gt;12.中断的上部和下部（没听过啊）&lt;/h4&gt;

&lt;p&gt;真不知道，听都没听过啊&lt;/p&gt;

&lt;h5 id='linux'&gt;总结：由于linux组做的都是驱动方面的，所以问的可能比较深，很多都没用过，没听过，估计悲剧，所以还是尽量深的去学习研究吧，不然怎么坑蒙拐骗面试官~&lt;/h5&gt;</description>
                <link>http://tinyfisher.github.com/blog/2013/09/22/ibm</link>
                <guid>http://tinyfisher.github.com/blog/2013/09/22/ibm</guid>
                <pubDate>2013-09-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Mongodb学习整理之内存映射机制</title>
                <description>&lt;p&gt;sql数据库在数据量达到百万级的时候性能直线下降，在建立索引的表上做一个条件查询甚至达到分钟级别查询时间，这是无法忍受的，瓶颈在于大量的磁盘i/o操作，而这些i/o操作无疑使很耗费时间的。mongodb之所以对海量数据的查询如此高效，是因为他使用了内存映射机制，避免了大量的磁盘i/o，从而大大提高了查询效率，但相应的对内存要求也比较高。ok，下面我们来看看什么是内存映射机制&lt;/p&gt;

&lt;h4 id='id27'&gt;官网的说法：&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;What are memory mapped files?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A memory-mapped file is a file with data that the operating system places in memory by way of the mmap() system call. mmap() thus maps the file to a region of virtual memory. Memory-mapped files are the critical piece of the storage engine in MongoDB. By using memory mapped files MongoDB can treat the contents of its data files as if they were in memory. This provides MongoDB with an extremely fast and simple method for accessing and manipulating data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How do memory mapped files work?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Memory mapping assigns files to a block of virtual memory with a direct byte-for-byte correlation. Once mapped, the relationship between file and memory allows MongoDB to interact with the data in the file as if it were memory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How does MongoDB work with memory mapped files?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MongoDB uses memory mapped files for managing and interacting with all data. MongoDB memory maps data files to memory as it accesses documents. Data that isn’t accessed is not mapped to memory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are page faults?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Page faults will occur if you’re attempting to access part of a memory-mapped file that isn’t in memory.&lt;/p&gt;

&lt;p&gt;If there is free memory, then the operating system can find the page on disk and load it to memory directly. However, if there is no free memory, the operating system must:&lt;/p&gt;

&lt;p&gt;find a page in memory that is stale or no longer needed, and write the page to disk.&lt;/p&gt;

&lt;p&gt;read the requested page from disk and load it into memory.&lt;/p&gt;

&lt;p&gt;This process, particularly on an active system can take a long time, particularly in comparison to reading a page that is already in memory.&lt;/p&gt;

&lt;h4 id='id28'&gt;我的理解：&lt;/h4&gt;

&lt;p&gt;首先，“映射”这个词，就和数学课上说的“一一映射”是一个意思，就是建立一种一一对应关系，在这里主要是只&lt;em&gt;硬盘上文件&lt;/em&gt;的位置与进程&lt;em&gt;逻辑地址空间&lt;/em&gt;中一块大小相同的区域之间的一一对应（按字节对应），如过程1所示。这种对应关系纯属是逻辑上的概念，物理上是不存在的，原因是进程的逻辑地址空间本身就是不存在的。在内存映射的过程中，&lt;strong&gt;并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存&lt;/strong&gt;，这个过程由系统调用mmap()实现，所以建立内存映射的效率很高。&lt;/p&gt;

&lt;p&gt;&lt;img alt='hello' src='/assets/themes/images/yxh.gif' /&gt;&lt;br /&gt;既然建立内存映射没有进行实际的数据拷贝，那么进程又怎么能最终直接通过内存操作访问到硬盘上的文件呢？那就要看内存映射之后的几个相关的过程了。&lt;/p&gt;

&lt;p&gt;mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件。但是ptr所指向的是一个逻辑地址，要操作其中的数据，必须通过内存管理单元MMU将逻辑地址转换成物理地址，如图1中过程2所示。这个过程与内存映射无关。&lt;/p&gt;

&lt;p&gt;前面讲过，建立内存映射并没有实际拷贝数据，这时，MMU在地址映射表中是无法找到与ptr相对应的物理地址的，也就是MMU失败，将产生一个缺页中断，缺页中断的中断响应函数会在swap中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过mmap()建立的映射关系，从硬盘上将文件读取到物理内存中，如图1中过程3所示。这个过程与内存映射无关。&lt;/p&gt;

&lt;p&gt;如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上，如图1中过程4所示。这个过程也与内存映射无关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以当mongodb读取数据库文件的时候，首先做内存映射，读取文件变成了读取内存操作，所以mongodb的查询效率相当高，当然，如果你的内存不够大，经常发生缺页中断，那么效率会大打折扣了&lt;/strong&gt;&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/linux/2013/09/21/mongodb-mmp</link>
                <guid>http://tinyfisher.github.com/linux/2013/09/21/mongodb-mmp</guid>
                <pubDate>2013-09-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ICAP RFC3507 部分章节翻译</title>
                <description>&lt;h4 id='icaphttprfc3507okicap'&gt;之前项目中用到了icap协议，成功实现了对http数据包的内容修改，增加等功能，现将一些协议中一些字段进行总结，参考了RFC3507，ok，让我们首先看一个icap报文&lt;/h4&gt;
&lt;pre class='prettyprint linenums lang-clj'&gt;
REQMOD  icap://127.0.0.1:1344/greasyspoon_req ICAP/1.0\r\n       
Host:127.0.0.1:1344\r\n                                     
Date:Wed, 08 May 2013 15:47:28 GMT\r\n                         
Encapsulated:req-hdr=0, null-body=336\r\n                                                      
Preview:0\r\n                                                    
Allow:204\r\n                               
\r\n                                     
GET   http://202.168.1.13/1.html HTTP/1.1\r\n                  
Host:   202.168.1.13\r\n                          
User-Agent:  Mozilla/5.0 (Windows NT 6.1; WOW64; rv:17.0) Gecko/20100101 
Firefox/17.0\r\n                        
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n  
Accept-Language:   en-US,en;q=0.5\r\n                  
Accept-Encoding:   gzip, deflate\r\n                    
Referer:  http://202.168.1.13/support.html\r\n                    
\r\n
&lt;/pre&gt;
&lt;p&gt;其中1到7行为icap头，剩下的是我们常见的http头，我们一条一条看一下：&lt;br /&gt;第一行中&lt;code&gt;REQMOD&lt;/code&gt;表示icap工作在请求模式，icap还有一种模式叫&lt;code&gt;RESPMOD&lt;/code&gt;，意思是工作在响应模式，&lt;strong&gt;简单的说，请求模式主要针对http请求报文进行匹配修改增值，响应模式主要针对http响应报文进行匹配修改增值&lt;/strong&gt;；&lt;code&gt;icap://127.0.0.1:1344/greasyspoon_req ICAP/1.0&lt;/code&gt;说的是资源url和版本号1.0，其中&lt;code&gt;greasyspoon&lt;/code&gt;是指icap服务器的具体名称，icap服务器还有c-icap等。&lt;br /&gt;&lt;code&gt;host&lt;/code&gt;和&lt;code&gt;date&lt;/code&gt;这里就不详细说了&lt;br /&gt;&lt;code&gt;Encapsulated:req-hdr=0, null-body=336\r\n &lt;/code&gt;说的是封装了http请求包，http头偏移量为0，这个请求包只有头，没有body，所以&lt;code&gt;null-body=336&lt;/code&gt;，336是指body的偏移量；如果有请求包的body的话,例如post消息，会出现下面的情况：&lt;br /&gt;&lt;code&gt;Encapsulated: req-hdr=0, req-body=412&lt;/code&gt;,意思是头偏移长度0，bdoy偏移长度为412，通过这个可以得到http头和消息体的开始位置，&lt;strong&gt;总结一下，&lt;code&gt;Encapsulated&lt;/code&gt;这个字段主要用来定位http消息的header和body。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;再来看&lt;code&gt;preview&lt;/code&gt;字段的用途，首先看一下RFC3507中对他的描述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ICAP REQMOD or RESPMOD requests sent by the ICAP client to the ICAP server may include a &amp;quot;preview&amp;quot;. This feature allows an ICAP server to see the beginning of a transaction, then decide if it wants to opt-out of the transaction early instead of receiving the remainder of the request message.   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;翻译如下：icap客户端发送给服务端的REQMOD或者RESPMOD请求可能包含“preview” 字段，它能让icap服务端看到事务的最开始的一些信息，从而决定是否直接退出这个事务，而不是等到将所有的请求信息接收完毕再做判断。&lt;strong&gt;说白了就是预览icap封装消息body的前n个字节，来判断是否对这个消息进行处理，而不是接收完所有消息再判断。&lt;/strong&gt;举个例子（RFC上的）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;If an ICAP server wants to transcode all GIF87 files into GIF89 files, then the GIF87 files could quickly be detected by looking at the first few body bytes of the file.  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;翻译：如果icap服务器想要把所有gif87的文件转码成gif89文件，gif87的文件可以通过body的前几行检测出来。&lt;/p&gt;

&lt;p&gt;这里由于我们的包里只有http header，没有http body，所以preview为0&lt;/p&gt;

&lt;p&gt;最后&lt;code&gt;Allow:204&lt;/code&gt;,我们先看看RFC上怎么说：&lt;br /&gt; An ICAP client MAY include &amp;#8220;Allow: 204&amp;#8221; in its request headers,indicating that the server MAY reply to the message with a &amp;#8220;204 NoContent&amp;#8221; response if the object does not need modification.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;If an ICAP server receives a request that does not have &amp;quot;Allow: 204&amp;quot;,it MUST NOT reply with a 204. In this case, an ICAP server MUST return the entire message back to the client, even though it is identical to the message it received.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;翻译：&amp;#8221;Allow: 204&amp;#8221;是可选的，加上这个选项表示：如果这个包不需要处理，则服务器返回&amp;#8221;204 NoContent&amp;#8221;给客户端，如果不加这个选项，服务器绝不会返回204，而是将整个消息返回给客户端&lt;br /&gt;&lt;strong&gt;总结一下：这个allow：204主要是真针对不需要处理的数据包进行简单返回状态码204，从而减少了icap服务器和客户端的工作量&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id='okicapicap'&gt;ok，到这里我们基本分析了icap的请求包，再来看看，icap服务器的返回包：&lt;/h4&gt;
&lt;pre class='prettyprint linenums lang-clj'&gt;
ICAP/1.0 200 OK\r\n 
ISTag:&quot;GreasySpoon-1.0.8-01&quot;\r\n                   
Host:0.0.0.0:1344\r\n                         
Encapsulated:req-hdr=0, null-body=333\r\n                 
Connection:close\r\n                          
\r\n                                     
GET http://202.168.2.34/2.html HTTP/1.1\r\n                 
Host:202.168.2.34\r\n                          
User-Agent:  Mozilla/5.0 (Windows NT 6.1; WOW64; rv:17.0) Gecko/20100101 
Firefox/17.0\r\n                         
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n     
Accept-Language:   en-US,en;q=0.5\r\n                   
Accept-Encoding:   gzip, deflate\r\n                     
Referer:http://202.168.1.13/support.html\r\n                   
\r\n                                     
&lt;/pre&gt;
&lt;p&gt;前6行为icap响应包头，下面的是修改后的http请求，可以看到&lt;code&gt;GET http://202.168.2.34/1.html HTTP/1.1\r\n&lt;/code&gt;改成了&lt;code&gt;GET http://202.168.2.34/2.html HTTP/1.1\r\n&lt;/code&gt;,我们成功修改了http请求。下面具体看一下响应包的各个字段：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ICAP/1.0 200 OK\r\n &lt;/code&gt;说的是icap的返回状态码200，表示http请求已经被成功修改，类似于http状态码200&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ISTag&lt;/code&gt;（ICAP Service Tag）说的是我们用的icap service的具体名称和版本号，我们这里用的是greasyspoon&lt;/p&gt;

&lt;p&gt;&lt;code&gt;host&lt;/code&gt;和&lt;code&gt;Encapsulated&lt;/code&gt;不再赘述了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Connection&lt;/code&gt;字段和http协议的connection一样，含义是当client和server通信时对于长链接如何进行处理。在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close.&lt;/p&gt;

&lt;p&gt;不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。&lt;/p&gt;

&lt;h4 id='http'&gt;顺便再复习一下http报文里的各个字段的含义：&lt;/h4&gt;

&lt;p&gt;1、 Accept：告诉WEB服务器自己接受什么介质类型，&lt;em&gt;/&lt;/em&gt; 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。&lt;/p&gt;

&lt;p&gt;2、 Accept-Charset： 浏览器申明自己接收的字符集&lt;/p&gt;

&lt;p&gt;Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）&lt;/p&gt;

&lt;p&gt;Accept-Language：：浏览器申明自己接收的语言&lt;/p&gt;

&lt;p&gt;语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。&lt;/p&gt;

&lt;p&gt;3、 Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。&lt;/p&gt;

&lt;p&gt;keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。&lt;/p&gt;

&lt;p&gt;响应：close（连接已经关闭）。&lt;/p&gt;

&lt;p&gt;keepalive（连接保持着，在等待本次连接的后续请求）。&lt;/p&gt;

&lt;p&gt;Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300&lt;/p&gt;

&lt;p&gt;4、 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn&lt;/p&gt;

&lt;p&gt;5、 Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/&lt;/p&gt;

&lt;p&gt;6、 Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix) 7、 User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/blog/2013/09/21/icap</link>
                <guid>http://tinyfisher.github.com/blog/2013/09/21/icap</guid>
                <pubDate>2013-09-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>阿里巴巴面试总结</title>
                <description>&lt;p&gt;15号接到阿里通知，18号上午去面试，研究生期间第一次面试，颇为激动，准备了一番，18号去了大望路那里。前台签到后，在大厅等了一会，面试官拿着我的简历叫我跟他走，到了一个会议室，里面人很多，面试官的花名叫易统，阿里每个人都有花名，武侠风浓烈，马云的花名叫风清扬。。。易统说欢迎来面试，让我自我介绍，期间点开了我的blog- -&lt;/p&gt;

&lt;p&gt;后来主要是围绕简历上写得项目的技能，做了一些提问，主要是我在说，面试官如果感兴趣会深入问下去。时间在一个小时左右，易统十分友好，没有什么压力，问的问题待会详细记录。最后易统说今天的面试就到这里，让我回去了，我想完蛋了，因为之前得知如果面的好会直接二面的，看来是面挂了，而我自我感觉还不错，后来细想想，可能某些问题回答的不够深入，要反思了。问题总结如下：&lt;/p&gt;

&lt;h4 id='tcpip'&gt;tcp/ip三次握手&lt;/h4&gt;

&lt;p&gt;这个基本是滥问题了，答得还不错&lt;/p&gt;

&lt;h4 id='tcp'&gt;tcp有哪些机制保证了他的可靠性&lt;/h4&gt;

&lt;p&gt;这个答得不够好，这里总结下：&lt;/p&gt;

&lt;h5 id='id23'&gt;可靠性包括以下几个方面：&lt;/h5&gt;

&lt;p&gt;1.能够处理数据传输过程中被破坏问题。&lt;/p&gt;

&lt;p&gt;2.能够处理重复数据接收问题。&lt;/p&gt;

&lt;p&gt;3.能够发现数据丢失以及对此进行有效解决。&lt;/p&gt;

&lt;p&gt;4.能够处理接收端数据乱序到达问题。&lt;/p&gt;

&lt;h5 id='id24'&gt;怎么保证解决上述问题？&lt;/h5&gt;

&lt;p&gt;TCP协议规范和当前绝大多数TCP 协议实现代码均采用数据重传和数据确认应答机制来完成TCP 协议的可靠性数据传输。数据超时重传和数据应答机制的基本前提是对每个传输的字节进行编号，即我们通常所说的序列号。数据超时重传是发送端在某个数据包发送出去，在一段固定时间后如果没有收到对该数据包的确认应答，则（假定该数据包在传输过程中丢失）重新发送该数据包。而数据确认应答是指接收端在成功接收到一个有效数据包后，发送一个确认应答数据包给发送端主机，该确认应答数据包中所包含的应答序列号即指已接收到的数据中最后一个字节的序列号加1，加1 的目的在于指出此时接收端期望接收的下一个数据包中第一个字节的序列号。&lt;strong&gt;数据超时重传、数据确认应答以及对每个传输的字节分配序列号是TCP 协议提供可靠性数据传输的核心本质。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.解决数据传输中被破坏的问题&lt;/p&gt;

&lt;p&gt;首先通过对所接收数据包的&lt;strong&gt;CRC校验&lt;/strong&gt;，确认该数据包中数据是否存在错误。如果有，则简单丢弃或者发送一个应答数据包重新对这些数据进行请求。发送端在等待一段时间后，则会重新发送这些数据。本质上，数据传输错误的解决是通过&lt;strong&gt;数据重传机制&lt;/strong&gt;完成的。&lt;/p&gt;

&lt;p&gt;2.解决重复数据接收问题&lt;br /&gt;接到数据包之后，查看序列号，如果数据包已经接收过，则丢弃该数据包，返回确认信息，主要是通过&lt;strong&gt;序列号&lt;/strong&gt;解决这个问题&lt;/p&gt;

&lt;p&gt;3.解决数据丢失问题&lt;br /&gt;主要依靠tcp的&lt;strong&gt;重传机制&lt;/strong&gt;来解决。TCP通过在发送数据报文时设置一个超时定时器来解决这种问题，如果在定时器溢出时还没有收到来自对端对发送报文的确认，它就重传该数据报文。&lt;/p&gt;

&lt;p&gt;4.解决乱序问题&lt;br /&gt;如果通信双方存在多条传输路径， 则有可能出现数据乱序问题，即序列号较大的数据先于序列号较小的数据到达，而发送端确实是按序列号由小到大的顺序发送的。数据乱序的本质是数据都成功到达了，但到达的顺序不尽如人意。对于收到的乱序报文并不丢弃，而是缓存下来(这样做是为了减少更多的重传)，立即发送希望接受的报文确认。对这个问题的解决相对比较简单，只需对这些数据进行重新排序即可。本质上，对数据乱序问题的解决是通过&lt;strong&gt;排序数据序列号&lt;/strong&gt;完成的。&lt;/p&gt;

&lt;h4 id='syn_flood_'&gt;syn flood 攻击&lt;/h4&gt;

&lt;p&gt;由于是安全专业的，面试官又问了我这个问题，答得一般，总结如下：&lt;/p&gt;

&lt;h5 id='synflood'&gt;什么是synflood？&lt;/h5&gt;

&lt;p&gt;在TCP连接的三次握手中，假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）；一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，&lt;strong&gt;服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源&lt;/strong&gt;&amp;#8212;-数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的CPU时间和内存，何况还要不断对这个列表中的IP进行SYN+ACK的重试。实际上如果服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃&amp;#8212;即使服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYN Flood攻击（SYN洪水攻击）。&lt;/p&gt;

&lt;h5 id='syn_flood'&gt;怎么检测Syn flood？&lt;/h5&gt;

&lt;p&gt;1、服务端无法提供正常的TCP服务。连接请求被拒绝或超时；&lt;/p&gt;

&lt;p&gt;2、通过 &lt;code&gt;netstat -an&lt;/code&gt; 命令检查系统，发现有大量的&lt;code&gt;SYN_RECV&lt;/code&gt;连接状态。&lt;/p&gt;

&lt;h5 id='id25'&gt;如何防范？&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;缩短SYN- Timeout时间&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;设置每秒最多3个syn封包进入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id='linux_cpu'&gt;查看Linux CPU使用率命令&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;top&lt;/code&gt;&lt;/p&gt;

&lt;h4 id='id26'&gt;查看进程信息&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;ps -aux&lt;/code&gt;&lt;/p&gt;

&lt;h4 id='vim100200'&gt;vim从100到200行替换字符串&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;:100,200s/vivian/sky/g&lt;/code&gt;&lt;/p&gt;

&lt;h4 id='fluentdmongodboffer23'&gt;总结：简历上写的尽量往深处了解，面试官可能追问具体的机制，例如我用到的几个工具，fluentd，mongodb，我只是简单的使用，不清楚里面的实现机制，往往不能令面试官满意。面试失败的还有一个原因是简历上写的一定是自己非常了解的，不是很懂的还是不要往上写了，或者写了赶紧去补功课，路漫漫其修远兮，找工作是一个虐心的过程，相信经过不断的积攒经验，一定能够拿到满意的offer，下一站：创新工场23号面试，加油！&lt;/h4&gt;</description>
                <link>http://tinyfisher.github.com/blog/2013/09/20/alibaba</link>
                <guid>http://tinyfisher.github.com/blog/2013/09/20/alibaba</guid>
                <pubDate>2013-09-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Mongodb 学习整理之安装</title>
                <description>&lt;h3 id='id19'&gt;下载&lt;/h3&gt;

&lt;p&gt;下载MongoDB，此处下载的版本是：&lt;a href='http://fastdl.mongodb.org/linux/mongodb-linux-i686-1.8.1.tgz'&gt;mongodb-linux-i686-1.8.1.tgz.tar&lt;/a&gt;&lt;/p&gt;

&lt;h3 id='id20'&gt;安装&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;step1：&lt;/strong&gt;解压文件到某目录下,然后重命名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost src]# tar -xzvf mongodb-linux-i686-1.8.1.tgz.tar    
[root@localhost src]# mv mongodb-linux-i686-1.8.1 /usr/local/mongodb/  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;step2：&lt;/strong&gt;查看安装后的文件情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost src]# cd /usr/local/mongodb/   
[root@localhost mongodb]# ls   
bin  GNU-AGPL-3.0  README  THIRD-PARTY-NOTICES   
[root@localhost mongodb]# cd bin/   
[root@localhost bin]# ls   
bsondump  dbbak  mongo  mongod  mongodump  mongoexport  mongofiles  mongoimport  mongorestore mongos  mongosniff  mongostat    &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bin下的mongod就是MongoDB的服务端进程，mongo就是其客户端，其它的命令用于MongoDB的其它用途如MongoDB文件导出等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step3:&lt;/strong&gt;启动MongoDB:&lt;/p&gt;

&lt;p&gt;要先建立好MongoDB 存放数据文件和日志文件的目录，需要手动建立：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /data/mongodb_data
mkdir /data/mongodb_log
touch /data/mongodb_log/mongodb.log
[root@localhost etc]# cd /data/   
[root@localhost data]# ls   
mongodb_data  mongodb_log    &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在MongoDB安装目录下的bin下使用mongod启动MongoDB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./mongod --dbpath=/data/mongodb_data/ --logpath=/data/mongodb_log/mongodb.log --logappend&amp;amp;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待启动成功后，可查看是否启动成功了，默认端口号是27017，当然在启动时也可以指定未使用的其它端口。先通过查看端口号看MongoDB是否启动了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost data]# netstat -lanp | grep &amp;quot;27017&amp;quot;  
tcp   0    0 0.0.0.0:27017      0.0.0.0:*     LISTEN      1573/mongod            
unix  2  [ ACC ]    STREAM   LISTENING    5874  1573/mongod   /tmp/mongodb-27017.sock    &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，已启动成功，现在使用mongo客户端访问一下该数据库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost bin]# cd /usr/local/mongodb/bin/   
[root@localhost bin]# ./mongo   
MongoDB shell version: 1.8.1  
connecting to: test   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这一步说明已经安装成功了。&lt;/p&gt;

&lt;h3 id='id21'&gt;额外工作&lt;/h3&gt;

&lt;p&gt;注意，上述我们启动MongoDB都是手动使用mongod来启动，这样关闭计算机后，下次再进来它又没启动了，所以还得手动启动，因此，为避免这种繁琐的工作，可以把mongod放到服务自启动项中，这样计算机一开启mongod服务也就启动了。编辑/etc/rc.local，加入下述代码然后再保存即可。 (也可以写一个脚本，然后开机自动运行)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#add mongonDB service   
/usr/local/mongodb/bin/mongod --dbpath=/data/mongodb_data/ --logpath=/data/mongodb_log/mongodb.log --logappend&amp;amp;    &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者编写开机自启动脚本start_mongodb.sh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/local/mongodb-linux-i686-2.2.1/bin  //具体版本具体变化
./mongod --dbpath=/data/mongodb_data/ --logpath=/data/mongodb_log/mongodb.log --logappend&amp;amp;   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;路径和你设置mongodb的datapath，logpath一致 我们重启计算机再看MongoDB是否启动，重启后可以直接使用 mongo命令登录，最终发现是可以成功的。&lt;/p&gt;

&lt;p&gt;另外，我们使用mongo命令登录 MongoDB还要转到mongo命令所在目录再执行./mongo，这样是不是有些麻烦？因此，我们可以简化这点，将该命令文件copy到/usr/bin下，这样就可以在任何目录下使用mongo命令了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost bin]# ls   
bsondump  dbbak  mongo  mongod  mongodump  mongoexport  mongofiles  mongoimport  mongorestore mongos  mongosniff  mongostat   
[root@localhost bin]# cp mongo /usr/bin/    &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转到任一目录试下mongo命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost bin]# cd /   
[root@localhost /]# mongo   
MongoDB shell version: 1.8.1  
connecting to: test   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到登录成功了，说明我们可以像使用ls命令一样使用mongo命令了。&lt;/p&gt;

&lt;h3 id='id22'&gt;安装图形化界面&lt;/h3&gt;

&lt;p&gt;mongoDB有许多图形化操作软件，我使用的是UMongo：&lt;/p&gt;

&lt;p&gt;下载&lt;a href='https://github.com/agirbal/umongo/downloads'&gt;Umongo&lt;/a&gt;,解压文件，在终端运行&lt;code&gt;launch-umongo.sh&lt;/code&gt;脚本文件即可&lt;/p&gt;

&lt;p&gt;ok,至此我们已经安装好了MongoDB~&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/linux/2013/07/15/mongodb-install</link>
                <guid>http://tinyfisher.github.com/linux/2013/07/15/mongodb-install</guid>
                <pubDate>2013-07-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Mongodb 学习整理之介绍</title>
                <description>&lt;h2 id='what_is_mongodb'&gt;What is Mongodb?&lt;/h2&gt;

&lt;p&gt;MongoDB是一个高性能，开源，无模式的文档型数据库，是当前&lt;strong&gt;NoSQL&lt;/strong&gt;数据库产品中最热门的一种。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式。那什么是NoSQL呢？&lt;/p&gt;

&lt;h3 id='what_is_nosql'&gt;What is NoSQL?&lt;/h3&gt;

&lt;p&gt;NoSQL，全称是”&lt;strong&gt;Not Only Sql&lt;/strong&gt;”,指的是非关系型的数据库。这类数据库主要有这些特点：非关系型的、分布式的、开源的、水平可扩展的。原始的目的是为了大规模web应用。NoSQL被我们用得最多的当数&lt;strong&gt;key-value&lt;/strong&gt;存储，当然还有其他的文档型的、列存储、图型数据库、xml数据库等。&lt;/p&gt;

&lt;h3 id='why_nosql'&gt;Why NoSQL?&lt;/h3&gt;

&lt;p&gt;随着互联网web2.0网站的兴起，传统的关系型数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如：&lt;/p&gt;

&lt;h4 id='id15'&gt;对数据库高并发读写的需求&lt;/h4&gt;

&lt;p&gt;web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。&lt;strong&gt;关系型数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO 就已经无法承受了&lt;/strong&gt;，其实对于普通的BBS网站，往往也存在对高并发写请求的需求。&lt;/p&gt;

&lt;h4 id='id16'&gt;对海量数据的高效率存储和访问的需求&lt;/h4&gt;

&lt;p&gt;对于大型的SNS网站，每天用户产生海量的用户动态信息，以国外的Friend feed为例，一个月就达到了2.5亿条用户动态，&lt;strong&gt;对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的&lt;/strong&gt;。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。&lt;/p&gt;

&lt;h4 id='id17'&gt;对数据库的高可扩展性和高可用性的需求&lt;/h4&gt;

&lt;p&gt;在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，可是停机维护随之带来的就是公司收入的减少&lt;/p&gt;

&lt;p&gt;基于以上三点，NoSQL在现在越来越流行。&lt;/p&gt;

&lt;h2 id='why_mongodb'&gt;Why Mongodb?&lt;/h2&gt;

&lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。&lt;strong&gt;他支持的数据结构非常松散，是类似json 的bjson格式，因此可以存储比较复杂的数据类型&lt;/strong&gt;。MongoDB最大的特点是他&lt;strong&gt;支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引&lt;/strong&gt;。它是一个面向集合的,模式自由的文档型数据库。&lt;/p&gt;

&lt;p&gt;ok，既然MongoDB如此神奇，那么我们该怎么安装和使用他呢？下篇blog继续介绍。&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/linux/2013/07/09/mongodb-introduce</link>
                <guid>http://tinyfisher.github.com/linux/2013/07/09/mongodb-introduce</guid>
                <pubDate>2013-07-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>利用Hostapd搭建无线wifi</title>
                <description>&lt;p&gt;网上这类文章一大堆，但都有一些问题，应该是环境不一样，所以在搭建之前，先说下我的环境：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Linux系统：&lt;code&gt;ubuntu 10.04&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;无线网卡：&lt;code&gt;TP-LINK WN822N&lt;/code&gt;（需要网卡支持Master模式，其他网卡请自行搜索）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ok, 下面介绍如何搭建：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step1：&lt;/strong&gt;安装网卡驱动，网卡都不识别的话就gg了，请参见我的博文&lt;a href='http://tinyfisher.github.io/linux/2013/03/05/tplink/'&gt;《TL-WN822N TL-WN722N linux安装驱动》&lt;/a&gt;，识别之后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifconfig wlan1 10.0.0.1  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为网卡设置ip地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step2：&lt;/strong&gt;下载&lt;a href='http://hostap.epitest.fi/releases/hostapd-1.1.tar.gz'&gt;hostapd&lt;/a&gt;，在解压安装之前，先安装libnl和libssl，否则hostapd无法编译通过，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install libnl-dev
sudo apt-get install libssl-dev  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;step3：&lt;/strong&gt;安装hostapd，解压压缩包，终端进入到hostapd文件夹，&lt;code&gt;configure&lt;/code&gt;，&lt;code&gt;make&lt;/code&gt;，&lt;code&gt;make install&lt;/code&gt; 常见的三个步骤&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step4：&lt;/strong&gt;修改配置文件，在hostapd文件夹里的etc目录下，找到&lt;code&gt;hostapd.conf&lt;/code&gt;文件，编辑如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface=wlan1 // 根据你的无线网卡名修改
driver=nl80211  //重要
ssid=tinyfisher  //这是AP名称
channel=6
hw_mode=g
ignore_broadcast_ssid=0
auth_algs=1
wpa=3
wpa_passphrase=xxxxxxxx   //这是你的密码
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动hostapd，命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./hostapd -B hostapd.conf  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后就可以搜索到 tinyfisher的wifi了。&lt;/p&gt;

&lt;p&gt;但是此时设备还不能通过wifi上网，还需要搭建dhcp服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install dnsmasq  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改&lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interface=wlan1 #根据你的网卡名称修改
dhcp-range=10.0.0.10,10.0.0.110,6h     #设置dhcp地址范围，即租借时间6小时
dhcp-option=3,10.0.0.1 #配置网关
dhcp-option=6,202.114.128.2  #配置dns，请自己修改为外网的dns地址  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dnsmasq：/etc/init.d/dnsmasq restart  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok，此时连接到wifi上的设备都能被随机分配到从&lt;code&gt;10.0.0.10~10.0.0.110&lt;/code&gt; 的地址&lt;/p&gt;

&lt;p&gt;现在就能上网了吗？不行，我们还需要一个外网出口，并且将内网的流量通过这个外网接口连出去，其实就是做一个&lt;code&gt;SNAT&lt;/code&gt;，所以我们还需要设置&lt;code&gt;iptables&lt;/code&gt;，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t nat -A POSTROUTING -s 10.0.0.0/8 -o eth0 -j MASQUERADE    //其中eth0就是外网接口，请根据你的实际情况修改  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一步，开启网卡转发功能：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo 1 &amp;gt;/proc/sys/net/ipv4/ip_forward  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定收工！&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/linux/2013/06/23/hostapd</link>
                <guid>http://tinyfisher.github.com/linux/2013/06/23/hostapd</guid>
                <pubDate>2013-06-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>2013微软暑期实习笔试错题、疑题整理</title>
                <description>&lt;h3 id='id14'&gt;参加了微软“智在未来”暑期实习笔试，跪了，将错题、疑题整理如下，方便后面复习整理。&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;What&amp;#8217;s the output of the following code?(3 Points)&lt;/strong&gt; B&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class A  
{  
public:  
    virtual void f()  
    {  
        cout&amp;lt;&amp;lt;&amp;quot;A::f()&amp;quot;&amp;lt;&amp;lt;endl;  
    }  
    void f() const  
    {  
        cout&amp;lt;&amp;lt;&amp;quot;A::f() const&amp;quot;&amp;lt;&amp;lt;endl;  
    }  
};  
  
class B: public A  
{  
public:  
    void f()  
    {  
        cout&amp;lt;&amp;lt;&amp;quot;B::f()&amp;quot;&amp;lt;&amp;lt;endl;  
    }  
    void f() const  
    {  
        cout&amp;lt;&amp;lt;&amp;quot;B::f() const&amp;quot;&amp;lt;&amp;lt;endl;  
    }  
};  
  
void g(const A* a)  
{  
    a-&amp;gt;f();  
}  
  
int main()  
{  
    A* a = new B();  
    a-&amp;gt;f();  
    g(a);  
    delete a ;  
}  

A. B::f()B::f()const    
B. B::f()A::f()const  
C. A::f()B::f()const    
D. A::f()A::f()const  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：类的成员函数后面加 const，&lt;strong&gt;表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改&lt;/strong&gt;变。&lt;/p&gt;

&lt;p&gt;在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更加明确的限定：&lt;strong&gt;有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？&lt;strong&gt;那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is the difference between a linked list and an array?(3 Points)&lt;/strong&gt; （全选）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. Search complexity when both are sorted  

B. Dynamically add/remove  

C. Random access efficiency  

D. Data storage type  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;【此题D选项存在疑问】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;About the Thread and Process in Windows, which description(s) is(are) correct:(3 Points)&lt;/strong&gt; C&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. One application in OS must have one Process, but not a necessary to have one Thread  

B. The Process could have its own Stack but the thread only could share the Stack of its parent Process  

C. Thread must belongs to a Process  

D. Thread could change its belonging Process  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：A选项，一个程序至少有一个进程，一个进程至少包含一个线程（主线程）&lt;/p&gt;

&lt;p&gt;B选项，线程共享父进程的数据空间，也可以拥有自己的栈空间&lt;/p&gt;

&lt;p&gt;C对，线程不能独立存在，必须属于一个进程&lt;/p&gt;

&lt;p&gt;D明显错误&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Please choose the right statement about const usage:(3 Points)&lt;/strong&gt; ABC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. const int a; //const integer  

B. int const a; //const integer  

C. int const *a; //a pointer which point to const integer  

D. const int *a; //a const pointer which point to integer  

E. int const *a; // a const pointer which point to integer  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：这里注意一下A、B的写法均可，两者意思一样&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 of 1000 bottles of water is poisoned which will kill a rat in 1 week if the rat drunk any amout of the water. Given the bottles of water have no visual difference, how many rats are needed at least to find the poisoned one in 1 week?(5 Points)&lt;/strong&gt; B&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. 9  

B. 10  

C. 32  

D. None of the above  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：2的10次方=1024，大于1000，用二进制的思维思考问题&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Which of the following statement(s) equal(s) value 1 in C programming language?(5 Points)&lt;/strong&gt; BCD&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. the return value of main function if program ends normally

B. return (7&amp;amp;1)  

C. char *str=&amp;quot;microsoft&amp;quot;; return str==&amp;quot;microsoft&amp;quot;  

D. return &amp;quot;microsoft&amp;quot;==&amp;quot;microsoft&amp;quot;  

E. None of the above  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：A选项，C程序正常退出，return 0；&lt;/p&gt;

&lt;p&gt;B选项，计算即可得&lt;/p&gt;

&lt;p&gt;C选项，因为C语言中是没有bool类型的（1个字节，只有0,1），所以返回1&lt;/p&gt;

&lt;p&gt;D选项，同C&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How many rectangles you can find from 3X4 grid?(5 Points)&lt;/strong&gt; D&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. 18  

B. 20  

C. 40  

D. 60 

E. None of above is correct  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：智力题 整不了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Which of the following sorting algorithm(s) is(are) stable sorting?(5 Points)&lt;/strong&gt; A&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. bubble sort  

B. quick sort  

C. heap sort  

D. merge sort  

E. Selection sort  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：不稳定排序：“快选希堆”，原地排序：“快选希堆冒”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Model-View-Controller(MVC) is an architectural pattern that frequently used in web applications. Which of the following statement(s) is(are) correct:(5 Points)&lt;/strong&gt; AB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. Models often represent data and the business logics needed to manipulate the data in the application  

B. A view is a (visual) representation of its model. It renders the model into a form suitable for interaction, typically a user interface element  

C. A controller is the link between a user and the system. It accepts input from the user and instructs the model and a view to perform actions based on that input  

D. The common practice of MVC in web applications is, the model receives GET or POST input from user and decides what to do with it, handing over to controller and which hand control to views(HTML-generating components)  

E. None of the above  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：不是很清楚，关于MVC，请看这篇blog，写得挺直白的&lt;a href='http://www.ruanyifeng.com/blog/2007/11/mvc.html'&gt;http://www.ruanyifeng.com/blog/2007/11/mvc.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Given a set of N balls and one of which is defective (weighs less than others), you are allowed to weigh with a balance 3 times to find the defective. Which of the following are possible N?(13 Points)&lt;/strong&gt; ABCD&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. 12  

B. 16  

C. 20  

D. 24  

E. 28  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：A选项：第一次：4,4,4 第二次：2,2，第三次：1,1, B选项：第一次：5,5,6，第二次：若在某一个5中，2,2,1；若在6中，2,2,2,；第三次1,1, C选项：第一次：7,7,6,；第二次：若在某一个7中，2,2,3；若在6中，2,2,2；第三次，1,1 D选项：第一次：8,8,8；第二次：2,3,3；第三次1,1&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/blog/2013/05/23/microsoft_test</link>
                <guid>http://tinyfisher.github.com/blog/2013/05/23/microsoft_test</guid>
                <pubDate>2013-05-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>fluentd插件开发</title>
                <description>&lt;p&gt;fluentd默认支持了一些插件，如apache，但是最近做项目对squid日志进行分析时，发现fluentd没有这个默认插件，需要自己开发，方法如下 自己编写一个ruby脚本，比如:&lt;code&gt;in_mytail.rb&lt;/code&gt;,将他放到&lt;code&gt;/etc/td-agent/plugin&lt;/code&gt; 即可&lt;/p&gt;

&lt;p&gt;修改&lt;code&gt;/etc/td-agent/td-agent.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;source&amp;gt;
	type mytail
	path /path/to/myformat_file
	tag myapp.mytail
&amp;lt;source&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签里面是日志来源，type表示input插件类型，这里是自己编写的类型，path是源日志文件，tag是标签，用于区分其他插件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;match **&amp;gt;
	type stdout
&amp;lt;/match&amp;gt;  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用于输出，这里输出到stdout，可以是file，mongodb等，看自己需要. 调试模式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;td-agent -vv  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ruby脚本如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyTailInput &amp;lt; Fluent::TailInput  
  Fluent::Plugin.register_input(&amp;#39;mytail&amp;#39;, self)  
  
  # Override &amp;#39;configure_parser(conf)&amp;#39; method.  
  # You can get config parameters in this method.  
  def configure_parser(conf)  
    @time_format = conf[&amp;#39;time_format&amp;#39;] || &amp;#39;%Y-%M-%d %H:%M:%S&amp;#39;  
  end  
    
  # Override &amp;#39;parse_line(line)&amp;#39; method that returns time and record.  
  # This example method assumes following log format:  
  #   %Y-%m-%d %H:%M:%S\tkey1\tvalue1\tkey2\tvalue2...  
  #   %Y-%m-%d %H:%M:%S\tkey1\tvalue1\tkey2\tvalue2...  
  #   ...  
  def parse_line(line)  
    elements = line.split(&amp;quot;\t&amp;quot;)  
    time=&amp;quot;2012-11-11 11:11:11&amp;quot;  #why unknow  
    t_time = Time.strptime(time, @time_format).to_i  
    record = {}  
    record[&amp;#39;logtime&amp;#39;]=elements[0]  
    record[&amp;#39;logcontent&amp;#39;]=elements[1]  
    return t_time, record  
  end  
end  &lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/linux/2013/05/01/fluentd</link>
                <guid>http://tinyfisher.github.com/linux/2013/05/01/fluentd</guid>
                <pubDate>2013-05-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Mongodb的备份与恢复</title>
                <description>&lt;p&gt;坑爹的保密检查需要擦除硬盘，所有环境都需要重新安装，Mongodb数据库需要进行备份，还好Mongodb为我们提供了&lt;code&gt;mongodump&lt;/code&gt;和&lt;code&gt;mongorestore&lt;/code&gt;两种方法，非常方便。&lt;/p&gt;

&lt;p&gt;进到mongodb的bin目录下：&lt;/p&gt;

&lt;p&gt;备份：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongodump -d Injection   //Injection 就是你要备份的数据库&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行之后会生成dump文件夹，里面子目录Injection就是备份的数据&lt;/p&gt;

&lt;p&gt;恢复：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongorestore -d Injection dump/Injection&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完成的备份与恢复，是不是十分方便呢~随后送上其他环境配置日志，坑爹的保密检查。&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/linux/2013/04/23/mongodb</link>
                <guid>http://tinyfisher.github.com/linux/2013/04/23/mongodb</guid>
                <pubDate>2013-04-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>TL-WN822N TL-WN722N linux安装驱动</title>
                <description>&lt;p&gt;这两款的芯片都是AR系列的芯片，所以只要安装这款芯片的驱动：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ath9k_htc&lt;/code&gt;即可,只需要两步&lt;/p&gt;

&lt;p&gt;(1)安装&lt;a href='https://www.kernel.org/pub/linux/kernel/projects/backports/stable/v3.7.9/'&gt;compat-drivers-3.7.9-1.tar.gz&lt;/a&gt;,这类似于万能驱动，里面包含了很多芯片的驱动，很好用，编译时间有点长，耐心等待&lt;/p&gt;

&lt;p&gt;下载完成之后，将压缩包解压，从命令行终端进入到解压的文件夹中，输入命令&lt;code&gt;sudo make&lt;/code&gt;，等待时间较长，再输入命令 &lt;code&gt;make install&lt;/code&gt;,等待时间也较长，便完成了安装&lt;/p&gt;

&lt;p&gt;(2)安装&lt;a href='http://nl.archive.ubuntu.com/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.60_all.deb'&gt;linux-firmware&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下载完成之后，直接双击文件包，即可自动安装&lt;/p&gt;

&lt;p&gt;重新启动 ，插上usb无线网卡，命令行输入&lt;code&gt;ifconfig -a&lt;/code&gt; ，如果出现&lt;code&gt;wlan0&lt;/code&gt;，&lt;code&gt;wlan1&lt;/code&gt; 等信息，则驱动成功&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/linux/2013/03/05/tplink</link>
                <guid>http://tinyfisher.github.com/linux/2013/03/05/tplink</guid>
                <pubDate>2013-03-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用ip route命令实现多链路负载均衡</title>
                <description>&lt;p&gt;其实在linux下实现多链路负载均衡很简单，只需借助ip route命令即可。&lt;/p&gt;

&lt;p&gt;环境：&lt;code&gt;ubuntu 10.04&lt;/code&gt; ，两个3G网卡，分别为&lt;code&gt;CDMA2000&lt;/code&gt; 和 &lt;code&gt;WCDMA&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分别将两个网卡拨号上网，方法不再具体描述，拨号成功后会多出两条链路&lt;code&gt;ppp0&lt;/code&gt;和&lt;code&gt;ppp1&lt;/code&gt;，注意拨号脚本里不要添加默认网关，（具体请参见&lt;a href='http://tinyfisher.github.io/linux/2013/01/29/ppp/'&gt;《pppd拨号与默认网关》&lt;/a&gt;），而是手动添加两条默认路由。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;利用&lt;code&gt;iptables&lt;/code&gt;进行&lt;code&gt;nat&lt;/code&gt;转换，不再赘述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.此时路由表里会有两条默认路由，其实只有第一个起作用，所有的流量都会从这条链路出去，没有实现负载均衡的效果，只需使用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ip route replace default equalize nexthop dev ppp0 weight 1 nexthop dev ppp1 weight 1   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中weight表示权重，根据链路的实际情况设置相应数值。&lt;/p&gt;

&lt;p&gt;4.测试：内网机器进行网络活动，在网关利用命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tc -s qdisc ls dev ppp0,tc -s qdisc ls dev ppp1  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别查看两条链路的流量，发现基本流量是按照1:1的比率的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：内网的机器通过多链路网关访问外网速度比单链路得到提升，但是网关本身访问外网的速度比单链路要慢得多，甚至不能访问网站，原因不详，猜想是http数据包从不同的链路进出，不能很好的拼凑给网关。总之现在这个项目不需要网关访问外网，留待以后再讨论。&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/linux/2013/02/07/loadbalance</link>
                <guid>http://tinyfisher.github.com/linux/2013/02/07/loadbalance</guid>
                <pubDate>2013-02-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>pppd拨号与默认网关</title>
                <description>&lt;p&gt;在linux下使用3G网卡上网，使用pppd工具进行拨号，拨号脚本如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nodetach
/dev/ttyUSB0
19200
nocrtscts
connect &amp;#39;/usr/sbin/chat -v -f /etc/ppp/peers/chat_script_unicom&amp;#39;
debug
user &amp;quot;card&amp;quot;
password &amp;quot;card&amp;quot;
ipcp-accept-local
ipcp-accept-remote
defaultroute&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;defaultroute&lt;/code&gt;表示拨号成功后，自动添加一条默认路由，如果只使用一个网卡拨号，当然很方便;&lt;/p&gt;

&lt;p&gt;但是我发现如果使用两个以上的网卡进行拨号，会产生多条默认路由，这当然也没有问题，只是当其中一条断开后，所有的默认路由都消失了，即使其他的网卡工作正常，也不能上网，所以当有多个网卡拨号的时侯，不建议使用&lt;code&gt;defaultroute&lt;/code&gt;这个选项，可以手动添加默认路由：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;route add default gw x.x.x.x&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/linux/2013/01/29/ppp</link>
                <guid>http://tinyfisher.github.com/linux/2013/01/29/ppp</guid>
                <pubDate>2013-01-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>DP实例之最长上升子序列LIS</title>
                <description>&lt;pre&gt;&lt;code&gt;/*
    LIS:最长递增子序列，例如：23453267，最长递增子序列为：234567
    lis(i)表示以a[i]结束的递增子序列的长度
    lis(i)=max{lis(k)+1,1}  k from 0 to i-1
    最长递增子序列长度为max(lis[]);
*/


int LIS(int a[],int len)
{
   int *p=(int *)malloc(sizeof(int)*len);
   int i=0;
   int j=0;
   int result=0;
   if(p==NULL)
        return -1;
   for(i=0;i&amp;lt;len;i++)
   {
       p[i]=1;
       for(j=0;j&amp;lt;i;j++)
       {
           if(a[i]&amp;gt;a[j]&amp;amp;&amp;amp;p[j]+1&amp;gt;p[i])
           {
               p[i]=p[j]+1;
           }
       }
   }
   for(i=0;i&amp;lt;len;i++)
   {
       if(result&amp;lt;p[i])
       {
           result =p[i];
       }
   }
   free(p);
   return result;
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/algorithm/2013/01/23/LIS</link>
                <guid>http://tinyfisher.github.com/algorithm/2013/01/23/LIS</guid>
                <pubDate>2013-01-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>DP实例之最长公共子序列LCS</title>
                <description>&lt;pre&gt;&lt;code&gt;/*
    LCS：求最长公共子序列
    例如：s1=&amp;quot;abdrge&amp;quot;,s2=&amp;quot;adreg&amp;quot;,则LCS=&amp;quot;adre&amp;quot;
    状态方程：lcs(i,j)=lcs(i-1,j-1)+1,其中s1[i]=s2[j]
    或者 lcs(i,j)=max{lcs(i,j-1),lcs(i-1,j)}
*/
int LCS(char *a,char *b)
{
    int len_a=strlen(a);   //行
    int len_b=strlen(b);   //列
    int **len=NULL;
    int **r=NULL;
    int i=0;
    int j=0;
    int lcs_len=0;
    len=(int **)malloc(sizeof(int *)*(len_a+1));       //申请二维数组空间
    r=(int **)malloc(sizeof(int *)*(len_a+1));
    if (len==NULL||r==NULL)
        return -1;
    for(;i&amp;lt;=len_a;i++)
    {
        *(len+i)=(int *)malloc(sizeof(int)*(len_b+1));
        *(r+i)=(int *)malloc(sizeof(int)*(len_b+1));
        if (*(len+i)==NULL||*(r+i)==NULL)
            return -1;
    }

    //LCS状态方程
    for(i=0;i&amp;lt;=len_a;i++)     //初始化
    {
        for(j=0;j&amp;lt;=len_b;j++)
        {
            len[i][j]=0;
            r[i][j]=0;
        }
    }
    for(i=1;i&amp;lt;=len_a;i++)
    {
        for(j=1;j&amp;lt;=len_b;j++)
        {
            if(a[i-1]==b[j-1])
            {
                len[i][j]=len[i-1][j-1]+1;
                r[i][j]=1;
            }
            else if(len[i][j-1]&amp;gt;=len[i-1][j])  //左边的大于等于上边的
            {
                len[i][j]=len[i][j-1];
                r[i][j]=2;
            }
            else
            {
                 len[i][j]=len[i-1][j];
                 r[i][j]=3;
            }
        }
    }

    //打印公共子序列
    print_lcs(r,a,len_a,len_b);
    free(r);
    lcs_len= len[len_a][len_b];
    free(len);
    return lcs_len;
}

void print_lcs(int **r,char *a,int i,int j)
{
    if(i==0||j==0)
        return ;
    else if(r[i][j]==1)
    {
        print_lcs(r,a,i-1,j-1);
        printf(&amp;quot;%c&amp;quot;,*(a+i-1));
    }
    else if(r[i][j]==2)
        print_lcs(r,a,i,j-1);
    else
        print_lcs(r,a,i-1,j);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='alt text' src='/assets/themes/images/20130613111911031.png' /&gt;&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/algorithm/2012/12/12/LCS</link>
                <guid>http://tinyfisher.github.com/algorithm/2012/12/12/LCS</guid>
                <pubDate>2012-12-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>iptables配置笔记</title>
                <description>&lt;pre&gt;&lt;code&gt;1.配置准备
＃iptables -F //清除原有规则
＃iptables -X //清除自定义链
 
2.定义策略
＃iptables -P INPUT DROP //默认丢弃，即丢弃所有的包
＃iptables -P OUTPUT DROP
＃iptables -P FORWARD DROP
 
3.典型的规则配置实例
# iptables -A INPUT|OUTPUT|FORWARD -s 源IP -d 目的IP -p tcp|udp|icmp --sport 源端口--dport 目的端口 -j ACCEPT|DROP
 
4.添加规则
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放HTTP
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p tcp --sport 80 -j ACCEPT //针对本机,若本机不需要，可省略
＃iptables -A OUTPUT -p tcp --dport 80 -j ACCEPT
＃iptables -A FORWARD -p tcp --sport 80 -j ACCEPT //允许转发
＃iptables -A FORWARD -p tcp --dport 80 -j ACCEPT //下面类似
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放DNS
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p udp --sport 53 -j ACCEPT
＃iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
＃iptables -A FORWARD -p udp --sport 53 -j ACCEPT
＃iptables -A FORWARD -p udp --dport 53 -j ACCEPT
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放SMTP和POP3
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p tcp --sport 25 -j ACCEPT
＃iptables -A OUTPUT -p tcp --dport 25 -j ACCEPT
＃iptables -A INPUT -p tcp --sport 110 -j ACCEPT
＃iptables -A OUTPUT -p tcp --dport 110 -j ACCEPT
＃iptables -A FORWARD -p tcp --sport 25 -j ACCEPT
＃iptables -A FORWARD -p tcp --dport 25 -j ACCEPT
＃iptables -A FORWARD -p tcp --sport 110 -j ACCEPT
＃iptables -A FORWARD -p tcp --dport 110 -j ACCEPT
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放SSH
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p tcp --sport 22 -j ACCEPT
＃iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT
＃iptables -A FORWARD -p tcp --sport 22 -j ACCEPT
＃iptables -A FORWARD -p tcp --dport 22 -j ACCEPT
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放Telnet
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p tcp --sport 23 -j ACCEPT
＃iptables -A OUTPUT -p tcp --dport 23 -j ACCEPT
＃iptables -A FORWARD -p tcp --sport 23 -j ACCEPT
＃iptables -A FORWARD -p tcp --dport 23 -j ACCEPT
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放FTP
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p tcp --sport 21 -j ACCEPT
＃iptables -A OUTPUT -p tcp --dport 21 -j ACCEPT
＃iptables -A FORWARD -p tcp --sport 21 -j ACCEPT
＃iptables -A FORWARD -p tcp --dport 21 -j ACCEPT
＃iptables -A INPUT -p tcp --sport 20 -j ACCEPT
＃iptables -A OUTPUT -p tcp --dport 20 -j ACCEPT
＃iptables -A FORWARD -p tcp --sport 20 -j ACCEPT
＃iptables -A FORWARD -p tcp --dport 20 -j ACCEPT
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放SSL
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p tcp --sport 443 -j ACCEPT
＃iptables -A OUTPUT -p tcp --dport 443 -j ACCEPT
＃iptables -A FORWARD -p tcp --sport 443 -j ACCEPT
＃iptables -A FORWARD -p tcp --dport 443 -j ACCEPT
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放ICMP
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p icmp -j ACCEPT
＃iptables -A OUTPUT -p icmp -j ACCEPT
＃iptables -A FORWARD -p icmp -j ACCEPT
＃iptables -A FORWARD -p icmp -j ACCEPT
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放TCP
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p tcp -j ACCEPT
＃iptables -A OUTPUT -p tcp -j ACCEPT
＃iptables -A FORWARD -p tcp -j ACCEPT
＃iptables -A FORWARD -p tcp -j ACCEPT
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃开放udp
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -A INPUT -p udp -j ACCEPT
＃iptables -A OUTPUT -p udp -j ACCEPT
＃iptables -A FORWARD -p udp -j ACCEPT
＃iptables -A FORWARD -p udp -j ACCEPT
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃实现NAT
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to-source 1.2.3.4
＃iptables -t nat -A PREROUTING -d 192.168.1.0/24 -i eth1 -j DNAT --to-destination 1.2.3.4
 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃规则的保存和重载
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables-save -c &amp;gt; /etc/iptables-save
＃iptables-restore -c &amp;lt; /etc/iptables-save
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃根据数据出入网卡匹配，假设eth0连接内网，eth1连接外网
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
＃iptables –A INPUT –i eth0 –j ACCEPT  //从eth0流入的数据都接收
＃iptables – A FORWARD – o eth1 –j ACCEPT //从eth1流出的数据都转发&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上是一些基本配置，可以开放更多的服务，还可以进行更详尽的匹配，如源目地址，出入网卡等，以后可以根据要求进一步设置。&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/linux/2012/12/05/iptables</link>
                <guid>http://tinyfisher.github.com/linux/2012/12/05/iptables</guid>
                <pubDate>2012-12-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>makefile 编写问题记录</title>
                <description>&lt;p&gt;最近写了个小程序，用到了&lt;code&gt;pow()&lt;/code&gt;函数，我们都知道需要添加头文件&lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;，以及在&lt;code&gt;gcc&lt;/code&gt;编译的侍侯加上&lt;code&gt;-lm&lt;/code&gt;选项，但是这个&lt;code&gt;-lm&lt;/code&gt;选项的位值也是有讲究的，我之前的makefile如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;solution:solution.o
     gcc  -lm solution.o  -o solution 
solution.o:solution.c
     gcc  -c  solution.c&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;报出错误：&lt;code&gt;undefined reference to pow&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;原因是&lt;code&gt;-lm&lt;/code&gt;的位置在&lt;code&gt;solution.o&lt;/code&gt;之前，所以编译器链接的时侯先去链接&lt;code&gt;lm&lt;/code&gt;库，之后无法解释&lt;code&gt;solution.o&lt;/code&gt;里的&lt;code&gt;pow&lt;/code&gt;函数&lt;/p&gt;

&lt;p&gt;对于C/C++编译而言，读取编译选项是按照&lt;strong&gt;从左到右的&lt;/strong&gt;顺序执行的。那么当编译器遇到源文件的时候，就开始对源文件中用到的函数进行解析，找到相对应的函数的函数体或者说是实现（Definition of Function）。这个过程是按照先遇到不能解析的函数（unresolved function），然后在源文件选项后面的一些选项中寻找可能的函数体的信息，是这样的一个顺序进行的。那么我们可以发现对于 Makefile，由于包含函数体或者函数定义信息的编译选项出现在源文件之前，那么当编译器在源文件中遇到不能解析的函数时，在源文件之后的选项中寻找相关的信息，那么就出现了编译错误，也就是无法找到相关的函数定义。&lt;/p&gt;

&lt;p&gt;所以正确的makefile如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;solution:solution.o
     gcc  solution.o  -o solution  -lm
solution.o:solution.c
     gcc  -c  solution.c&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结：始终将-l库函数选项放在编译命令的最右边&lt;/strong&gt;&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/c/2012/11/23/makefile</link>
                <guid>http://tinyfisher.github.com/c/2012/11/23/makefile</guid>
                <pubDate>2012-11-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>DP实例之01背包问题C语言实现</title>
                <description>&lt;h4 id='id12'&gt;问题描述：&lt;/h4&gt;

&lt;p&gt;有N件物品和一个容量为V的背包。第i件物品的费用是&lt;code&gt;c[i]&lt;/code&gt;，价值是&lt;code&gt;w[i]&lt;/code&gt;。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。&lt;br /&gt;这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。&lt;/p&gt;

&lt;p&gt;用子问题定义状态：即&lt;code&gt;f[i][v]&lt;/code&gt;表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：&lt;code&gt;f[i][v]&lt;/code&gt;=&lt;code&gt;max{f[i-1][v],f[i-1][v-c[i]]+w[i]}&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;用二维数组记录每个子问题的值，避免重复计算，行从0到N，列从0到V。&lt;code&gt;f[][0]=0,f[0][]=0&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;很容易算出01背包的时间和空间复杂度，&lt;code&gt;O(V*N)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;C语言代码实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int Bag()  
{  
    int i,j;  
    int num=4;      //有4个物品  
    int vol=10;     //背包容量为10  
    int w[5]={0,3,1,4,3}; //此处需要多添加一个首元素元素0，因为下面的循环从1开始，若不添加0，则i-1会出现数组越界  
    int v[5]={0,1,3,4,2};//此处需要多添加一个首元素元素0，因为下面的循环从1开始，若不添加0，则i-1会出现数组越界  
    int f[5][11]={0}; //用来保存结果 ，以上几个数组长度都比num，vol多一个  
    for(i=1;i&amp;lt;=num;i++)  //状态方程  
    {  
        for(j=1;j&amp;lt;=vol;j++)  
        {  
            if (w[j]&amp;gt;j)                            //如果第i个物品放不进背包  
                f[i][j]=f[i-1][j];  
            else if(f[i-1][j]&amp;gt;(f[i-1][j-w[i]]+v[i]))    //状态方程 取&amp;lt;span style=&amp;quot;font-size: 14px;&amp;quot;&amp;gt;max{f[i-1][v],f[i-1][v-c[i]]+w[i]}&amp;lt;/span&amp;gt;  
                f[i][j]=f[i-1][j];  
            else  
                f[i][j]=f[i-1][j-w[i]]+v[i];  
        }  
    }  
    return f[4][10];  
}  &lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/algorithm/2012/11/02/bag</link>
                <guid>http://tinyfisher.github.com/algorithm/2012/11/02/bag</guid>
                <pubDate>2012-11-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>关于回调函数</title>
                <description>&lt;h3 id='id10'&gt;关于回调函数，搜集了一些网上的说法：&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.形象的例子：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你饿了,想吃饭,就一会去问你妈一声&amp;#8221;开饭没有啊?&amp;#8221;这就正常函数调用. 但是今天你妈包饺子,花的时间比较长,你跑啊跑啊,就烦了.于是你给你妈说,我先出去玩会,开饭的时候打我手机.等过了一阵,你妈给你打电话说&amp;#8221;开饭啦,快回来吃饭吧!&amp;#8221;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;其中,你告诉你妈打手机找你,就是个你把回调函数句柄保存到你妈的动作.你妈打电话叫你,就是个回调过程.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.为什么使用回调函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本质上都是“&lt;strong&gt;你想让别人的代码执行你的代码，而别人的代码你又不能动&lt;/strong&gt;”这种需求下产生的&lt;/p&gt;

&lt;p&gt;别人给你的不是源代码，是一个已经编译好的模块，并且不会给你源代码，那是商业机密，留给你一个接口，你把你要执行的代码以回调函数的形式交给这个接口，由别人编写的模块在需要的时候调用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.怎么调用回调函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用回调函数实际上就是在调用某个函数（通常是API函数）时，将自己的一个函数（这个函数为回调函数）的地址作为参数传递给那个函数。而那个函数在需要的时候，利用传递的地址调用回调函数，这时你可以利用这个机会在回调函数中处理消息或完成一定的操作。至于如何定义回调函数，跟具体使用的API函数有关，一般在帮助中有说明回调函数的参数和返回值等。C++中一般要求在回调函数前加CALLBACK，这主要是说明该函数的调用方式。&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/c/2012/10/07/callback</link>
                <guid>http://tinyfisher.github.com/c/2012/10/07/callback</guid>
                <pubDate>2012-10-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>分段和分页内存管理</title>
                <description>&lt;h3 id='id5'&gt;&lt;strong&gt;两者描述&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;打个比方，比如说你去听课，带了一个纸质笔记本做笔记。笔记本有100张纸，课程有语文、数学、英语三门，对于这个笔记本的使用，为了便于以后复习方便，你可以有两种选择。&lt;/p&gt;

&lt;p&gt;第一种是，你从本子的第一张纸开始用，并且事先在本子上做划分：第2张到第30张纸记语文笔记，第31到60张纸记数学笔记，第61到100张纸记英语笔记，最后在第一张纸做个列表，记录着三门笔记各自的范围。这就是分段管理，第一张纸叫段表。&lt;/p&gt;

&lt;p&gt;第二种是，你从第二张纸开始做笔记，各种课的笔记是连在一起的：第2张纸是数学，第3张是语文，第4张英语……最后呢，你在第一张纸做了一个目录，记录着语文笔记在第3、7、14、15张纸……，数学笔记在第2、6、8、9、11……，英语笔记在第4、5、12……。这就是分页管理，第一张纸叫页表。你要复习哪一门课，就到页表里查寻相关的纸的编号，然后翻到那一页去复习&lt;/p&gt;

&lt;h3 id='id6'&gt;&lt;strong&gt;两者的优缺点：&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。&lt;em&gt;段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。&lt;em&gt;页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）&lt;/em&gt;&lt;/p&gt;

&lt;h3 id='id7'&gt;&lt;strong&gt;两者的不同点：&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;(1) 分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。&lt;/p&gt;

&lt;p&gt;(2) 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。&lt;/p&gt;

&lt;p&gt;(3) 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。&lt;/p&gt;

&lt;h3 id='id8'&gt;&lt;strong&gt;两者结合——段页式存储管理：&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;1．基本思想：&lt;/p&gt;

&lt;p&gt;分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。&lt;/p&gt;

&lt;p&gt;在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。&lt;/p&gt;

&lt;p&gt;段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量&lt;/p&gt;

&lt;p&gt;程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。&lt;/p&gt;

&lt;p&gt;为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。&lt;/p&gt;

&lt;p&gt;2．地址变换的过程：&lt;/p&gt;

&lt;p&gt;（1）程序执行时，从PCB中取出段表始址和段表长度，装入段表寄存器。&lt;/p&gt;

&lt;p&gt;（2）由地址变换机构将逻辑地址自动分成段号、页号和页内地址。&lt;/p&gt;

&lt;p&gt;（3）将段号与段表长度进行比较，若段号大于或等于段表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。&lt;/p&gt;

&lt;p&gt;（4）将段表始址与段号和段表项长度的乘积相加，便得到该段表项在段表中的位置。&lt;/p&gt;

&lt;p&gt;（5）取出段描述子得到该段的页表始址和页表长度。&lt;/p&gt;

&lt;p&gt;（6）将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。&lt;/p&gt;

&lt;p&gt;（7）将页表始址与页号和页表项长度的乘积相加，便得到该页表项在页表中的位置。&lt;/p&gt;

&lt;p&gt;（8）取出页描述子得到该页的物理块号。&lt;/p&gt;

&lt;p&gt;（9）对该页的存取控制进行检查。&lt;/p&gt;

&lt;p&gt;（10）将物理块号送入物理地址寄存器中，再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中，拼接得到实际的物理地址。&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/linux/2012/09/23/OS-memory</link>
                <guid>http://tinyfisher.github.com/linux/2012/09/23/OS-memory</guid>
                <pubDate>2012-09-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>vim的备份和还原</title>
                <description>&lt;p&gt;vim是编辑神器，配置成IDE风格，用起来十分顺手，但是配置过程比较麻烦，前几天配置完了，重做系统还需要再配一遍吗，答案是否定的，如何还原vim环境呢？&lt;/p&gt;

&lt;p&gt;我的实验环境：&lt;code&gt;ubuntu10.04.2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step0&lt;/strong&gt;:安装vim：&lt;code&gt;sudo apt-get install vim&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step1:&lt;/strong&gt;备份文件：1.文件夹：&lt;code&gt;/.vim&lt;/code&gt; 2.配置文件：&lt;code&gt;/etc/vimrc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step2:&lt;/strong&gt;&lt;code&gt;sudo apt-get install exuberant-ctags&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step3:&lt;/strong&gt;复制刚才备份的文件到相应的目录下，并修改权限，简单暴力的777权限&lt;/p&gt;

&lt;p&gt;ok，还原成功！&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/vim/2012/09/01/vim</link>
                <guid>http://tinyfisher.github.com/vim/2012/09/01/vim</guid>
                <pubDate>2012-09-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>根据二叉树的先序和中序遍历还原二叉树</title>
                <description>&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
typedef struct node
{
	int value;
	struct node *left;
	struct node *right;
}Node,*pNode;

/*
 *根据二叉树的先序遍历和中序遍历，还原二叉树
 *先序：1,2,4,7,3,5,6,8;中序：4,7,2,1,5,3,8,6
*/

pNode BuildTree(int pre[],int mid[],int len)
{
	if(len&amp;lt;=0)
	{
		return NULL;
	}
	pNode root=(pNode)malloc(sizeof(Node));
	root-&amp;gt;value=pre[0];                    //先序的第一个节点一定是根节点
	int left_len=0;
	int right_len=0;
	int root_value=pre[0];
	int i=0;
	while(mid[i]!=root_value)              //获取左子树长度
	{
		i++;
		left_len++;
	}
	right_len=len-left_len-1;              //获取右子树长度
	//printf(&amp;quot;left_len is %d\n&amp;quot;,left_len);
	//printf(&amp;quot;right_len is %d\n&amp;quot;,right_len);
	root-&amp;gt;left=BuildTree(pre+1,mid,left_len);     //递归还原左子树
	root-&amp;gt;right=BuildTree(pre+1+left_len,mid+1+left_len,right_len);  //递归还原右子树
	return root;
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/btree/2012/08/26/btree-back</link>
                <guid>http://tinyfisher.github.com/btree/2012/08/26/btree-back</guid>
                <pubDate>2012-08-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>获取二叉树叶子数、高度及左右子树交换</title>
                <description>&lt;p&gt;二叉树的一些操作具有天然的递归性，本文实现了获取二叉树的叶子总数、获取二叉树高度以及交换二叉树的左右子树，代码均已编译通过。&lt;/p&gt;

&lt;p&gt;1.获取二叉树叶子总数：左子树叶子总数+右子树叶子总数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct BNode
{
    char value;  //类型假设为char
    struct BNode *left;
    struct BNode *right;

} Node,*pNode,**ppNode;
int GetLeafeNum(pNode root)
{
    if(root==NULL)  //空节点叶子数为0
    {
        return 0;
    }
    else if(root-&amp;gt;left==NULL&amp;amp;&amp;amp;root-&amp;gt;right==NULL)
    {
       return 1;
    }
    return GetLeafeNum(root-&amp;gt;left)+GetLeafeNum(root-&amp;gt;right);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.交换左右子树&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap_tree(pNode root)
{
    if(root==NULL)
        return;
    else
    {
        pNode temp=root-&amp;gt;left;
        root-&amp;gt;left=root-&amp;gt;right;
        root-&amp;gt;right=temp;
        swap_tree(root-&amp;gt;left);
        swap_tree(root-&amp;gt;right);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取二叉树高度：左右子树高度较大的+1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int GetHeight(pNode root)
{
    if(root==NULL)
    {
        return 0;
    }
    //max(left,right)+1; 左右子树最高高度+1
    return (GetHeight(root-&amp;gt;left)&amp;gt;=GetHeight(root-&amp;gt;right)?(GetHeight(root-&amp;gt;left)+1):(GetHeight(root-&amp;gt;right)+1));
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/btree/2012/08/21/btree-getinfo</link>
                <guid>http://tinyfisher.github.com/btree/2012/08/21/btree-getinfo</guid>
                <pubDate>2012-08-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>二叉树创建和遍历</title>
                <description>&lt;p&gt;二叉树的概念、性质等就不多介绍了，这里用C语言实现了二叉树的建立（1.用户输入，2.给数组参数），前中后序遍历和按层遍历。&lt;/p&gt;

&lt;p&gt;1.二叉树的建立&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct BNode
{
    char value;  //类型假设为char
    struct BNode *left;
    struct BNode *right;

} Node,*pNode,**ppNode;

pNode CreateBTree()  //通过输入建立二叉树，&amp;#39;@&amp;#39;表示空节点，先序顺序，空节点必须输入
{
    char ch;
    pNode q;
    scanf(&amp;quot; %c&amp;quot;,&amp;amp;ch);  //%c前面的空格 用来清空缓冲区
   // fflush(stdin);  //或者这样清空缓冲区
    if(ch==&amp;#39;@&amp;#39;)
    {
        return NULL;
    }
    else
    {
        q=(pNode)malloc(sizeof(Node));
        if(q==NULL)
        {
            printf(&amp;quot;malloc error\n&amp;quot;);
            return NULL;
        }
        q-&amp;gt;value=ch;
        q-&amp;gt;left=CreateBTree();
        q-&amp;gt;right=CreateBTree();
        return q;
    }

}

pNode CreateBTree_from_array(char a[],int index,int len) //根据数组创建二叉树双链表
{
	if(index&amp;gt;=len) //叶子节点
		return NULL;
	else
	{
	pNode root=(pNode)malloc(sizeof(Node));
	if(root==NULL)
	{
		printf(&amp;quot;malloc error\n&amp;quot;);
		return NULL;
	}
	root-&amp;gt;value=a[index];
	root-&amp;gt;left=CreateBTree_from_array(a,2*index+1,len);
	root-&amp;gt;right=CreateBTree_from_array(a,2*index+2,len);
	return root;
	}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.二叉树的前中后序遍历：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void preorder(pNode root)  //先序遍历
{
    if(root==NULL)
        return;
    else
    {
        printf(&amp;quot;%c&amp;quot;,root-&amp;gt;value);
        preorder(root-&amp;gt;left);
        preorder(root-&amp;gt;right);
    }
}

void midorder(pNode root)  //中序遍历
{
    if(root==NULL)
        return;
    else
    {
        midorder(root-&amp;gt;left);
        printf(&amp;quot;%c&amp;quot;,root-&amp;gt;value);
        midorder(root-&amp;gt;right);
    }
}

void postorder(pNode root)//后序遍历
{
    if(root==NULL)
        return;
    else
    {
        postorder(root-&amp;gt;left);
        postorder(root-&amp;gt;right);
        printf(&amp;quot;%c&amp;quot;,root-&amp;gt;value);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.二叉树按层遍历&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
    二叉树按层遍历，借助队列，构建一个队列专门用来储存二叉树节点指针，先把根节点入队，假设是A，对A元素进行访问，
    然后对A的左右孩子依次入队，假设B,C。A出队列，再是对B进行访问，同样将B的左右孩子入队列，B出对列······
    重复以上，直到队列为空。
*/
#define LEN 10
typedef struct queue  //队列，包含pNode数组，首尾index
{
    pNode data[LEN];
    int front;
    int rear;
}BTreeQueue,*pBTreeQueue;

void TransLevel(pNode root)
{
    pBTreeQueue pqueue=(pBTreeQueue)malloc(sizeof(BTreeQueue));
    pNode proot=root;
    pqueue-&amp;gt;front=0;
    pqueue-&amp;gt;rear=0;
    if(proot==NULL)
    {
        printf(&amp;quot;tree is null&amp;quot;);
        return;
    }
    else
    {
        printf(&amp;quot;%c&amp;quot;,proot-&amp;gt;value);
        pqueue-&amp;gt;data[pqueue-&amp;gt;front]=proot;  //根节点入队；
        (pqueue-&amp;gt;rear)++;
        while((pqueue-&amp;gt;front)&amp;lt;(pqueue-&amp;gt;rear))
        {
            proot=pqueue-&amp;gt;data[pqueue-&amp;gt;front];
            (pqueue-&amp;gt;front)++;  //队列首元素出列，保存为proot
            if(proot-&amp;gt;left!=NULL)
            {
                printf(&amp;quot;%c&amp;quot;,proot-&amp;gt;left-&amp;gt;value);
                pqueue-&amp;gt;data[pqueue-&amp;gt;rear]=proot-&amp;gt;left; //左子节点入队
                (pqueue-&amp;gt;rear)++;
            }
            if(proot-&amp;gt;right!=NULL)
            {
                printf(&amp;quot;%c&amp;quot;,proot-&amp;gt;right-&amp;gt;value);
                pqueue-&amp;gt;data[pqueue-&amp;gt;rear]=proot-&amp;gt;right; //右子节点入队
                (pqueue-&amp;gt;rear)++;
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/btree/2012/08/03/btree-create-traversal</link>
                <guid>http://tinyfisher.github.com/btree/2012/08/03/btree-create-traversal</guid>
                <pubDate>2012-08-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>双链表操作大全</title>
                <description>&lt;p&gt;双向链表的操作和单链表很像，主要包括创建，删除，插入；只要注意下指针的操作即可，废话不多说，直接上代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct dnode
{
    int num;
    struct dnode *pre;
    struct dnode *next;
}Dnode,*pDnode;

pDnode Create()  //用户输入创建，-1表示结束
{
    pDnode head=(pDnode)malloc(sizeof(Dnode));
    pDnode p=head;
    int a;
    printf(&amp;quot;please input :\n&amp;quot;);
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;a);
    while(a!=-1)
    {
        pDnode q=(pDnode)malloc(sizeof(Dnode));
        q-&amp;gt;num=a;
        p-&amp;gt;next=q;
        q-&amp;gt;pre=p;
        p=q;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;a);
    }
    p-&amp;gt;next=NULL;
    head=head-&amp;gt;next;
    head-&amp;gt;pre=NULL;
    return head;
}

pDnode CreateFromArray(int a[],int len)    //根据数组创建
{
    pDnode head=(pDnode)malloc(sizeof(Dnode));
    pDnode p=head;
    int i=0;
    while(i&amp;lt;len)
    {
        pDnode q=(pDnode)malloc(sizeof(Dnode));
        q-&amp;gt;num=a[i];
        p-&amp;gt;next=q;
        q-&amp;gt;pre=p;
        p=q;
        i++;
    }
    p-&amp;gt;next=NULL;
    head=head-&amp;gt;next;
    head-&amp;gt;pre=NULL;
    return head;
}

pDnode del(pDnode head, int key)   //删除
{
    pDnode q1=head;
    pDnode q2=head;
    if(head==NULL)
        return NULL;
    if(head-&amp;gt;num==key)
    {
        head=head-&amp;gt;next;
        head-&amp;gt;pre=NULL;
        free(q1);
        return head;
    }
    while(q1-&amp;gt;num!=key&amp;amp;&amp;amp;q1-&amp;gt;next!=NULL)
    {
        q2=q1;
        q1=q1-&amp;gt;next;
    }
    if(q1-&amp;gt;num==key&amp;amp;&amp;amp;q1-&amp;gt;next==NULL)
    {
        q2-&amp;gt;next=NULL;
        free(q1);
    }
    else if(q1-&amp;gt;num==key&amp;amp;&amp;amp;q1-&amp;gt;next!=NULL)
    {
        q2-&amp;gt;next=q1-&amp;gt;next;
        q1-&amp;gt;next-&amp;gt;pre=q2;
        free(q1);
    }
    else
    {
        printf(&amp;quot;not found\n&amp;quot;);
    }
    return head;
}

pDnode insert(pDnode head,int key)    // 插入
{
    pDnode s=(pDnode)malloc(sizeof(Dnode));
    s-&amp;gt;num=key;
    pDnode p=head;
    pDnode q=head;
    while(p-&amp;gt;num&amp;lt;key&amp;amp;&amp;amp;p-&amp;gt;next!=NULL)
    {
        p=p-&amp;gt;next;
    }
    if(p==head)
    {
        s-&amp;gt;next=head;
        head-&amp;gt;pre=s;
        head=s;
        head-&amp;gt;pre=NULL;
    }
    else if(p-&amp;gt;next==NULL&amp;amp;&amp;amp;p-&amp;gt;num&amp;lt;key)
    {
        p-&amp;gt;next=s;
        s-&amp;gt;pre=p;
        s-&amp;gt;next=NULL;
    }
    else
    {
        q=p-&amp;gt;next;
        p-&amp;gt;next=s;
        s-&amp;gt;next=q;
        s-&amp;gt;pre=p;
        q-&amp;gt;pre=s;
    }
    return head;
}

void print_from_head(pDnode head)  //打印
{
    while(head-&amp;gt;next!=NULL)
    {
        printf(&amp;quot;%d&amp;quot;,head-&amp;gt;num);
        head=head-&amp;gt;next;
    }
    printf(&amp;quot;%d&amp;quot;,head-&amp;gt;num);
    printf(&amp;quot;\n&amp;quot;);
}

void print_from_tail(pDnode head)
{
    while(head-&amp;gt;next!=NULL)
        head=head-&amp;gt;next;
    while(head-&amp;gt;pre!=NULL)
    {
        printf(&amp;quot;%d&amp;quot;,head-&amp;gt;num);
        head=head-&amp;gt;pre;
    }
    printf(&amp;quot;%d&amp;quot;,head-&amp;gt;num);
    printf(&amp;quot;\n&amp;quot;);
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/link/2012/08/01/doublelink</link>
                <guid>http://tinyfisher.github.com/link/2012/08/01/doublelink</guid>
                <pubDate>2012-08-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>单链表操作大全</title>
                <description>&lt;p&gt;单链表的操作一般包括：建立，删除节点，插入节点，链表反转&lt;/p&gt;

&lt;p&gt;1.单链表建立，包括从终端输入和由数组转换而来两种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct node
{
    int num;
    struct node * next;
}Node,*pNode;

pNode CreateLink()
{
    pNode head=(pNode)malloc(sizeof(Node));
    pNode p=head;
    int a;
    printf(&amp;quot;please input:\n&amp;quot;);
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;a);
    while(a!=-1)
    {
        pNode q=(pNode)malloc(sizeof(Node));
        q-&amp;gt;num=a;
        p-&amp;gt;next=q;
        p=q;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;a);
    }
    p-&amp;gt;next=NULL;
    head=head-&amp;gt;next;
    return head;
}

pNode CreateLinkFromArray(int a[],int len)
{
    pNode head=(pNode)malloc(sizeof(Node));
    pNode p=head;
    int i=0;
    while(i&amp;lt;len)
    {
        pNode q=(pNode)malloc(sizeof(Node));
        q-&amp;gt;num=a[i];
        p-&amp;gt;next=q;
        p=q;
        i++;
    }
    p-&amp;gt;next=NULL;
    head=head-&amp;gt;next;
    return head;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.单链表删除节点，考虑删除头结点，尾节点和中间节点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pNode del(pNode head,int key)
{
pNode p=head;
pNode q=head;
if(p==NULL) &amp;amp;nbsp; //若链表为空
{
    return NULL;
}
if(p-&amp;gt;num==key) //删除头指针
{
    head=head-&amp;gt;next;
    free(p);    // 释放删除节点空间
    return head;
}
while(p-&amp;gt;num!=key&amp;amp;&amp;amp;p-&amp;gt;next!=NULL) //遍历链表直到最后一个元素 寻找key，若有删掉
{
    q=p;
    p=p-&amp;gt;next;
}
if(p-&amp;gt;next==NULL&amp;amp;&amp;amp;p-&amp;gt;num==key) //删除尾元素
{
    q-&amp;gt;next=NULL;
    free(p);
}
else if(p-&amp;gt;next!=NULL) &amp;amp;nbsp;//删除中间元素
{
    q-&amp;gt;next=p-&amp;gt;next;
    free(p);
}
else
{
    printf(&amp;quot;not found\n&amp;quot;);
}
return head;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.单链表插入元素，考虑插入头结点，尾节点和中间节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pNode insert(pNode head,int value)
{
    pNode s=(pNode)malloc(sizeof(Node));
    s-&amp;gt;num=value;
    pNode p=head;
    pNode q=head;
    if(head==NULL) //链表为空
    {
        s-&amp;gt;next=NULL;
        return s;
    }
    while(p-&amp;gt;num&amp;lt;value&amp;amp;&amp;amp;p-&amp;gt;next!=NULL)
    {
        q=p;
        p=p-&amp;gt;next;
    }
    if(p-&amp;gt;next==NULL&amp;amp;&amp;amp;p-&amp;gt;num&amp;lt;value)  //插入尾节点
    {
        p-&amp;gt;next=s;
        s-&amp;gt;next=NULL;
        return head;
    }
    else if(p==head) //插入头结点
    {
        p=s;
        s-&amp;gt;next=q;
        return p;
    }
    else
    {
        q-&amp;gt;next=s;
        s-&amp;gt;next=p;
        return head;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.单链表反转&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pNode reverse(pNode head)
{
    if(head==NULL)
    {
        return NULL;
    }
    if(head-&amp;gt;next==NULL)
    {
        return head;
    }
    pNode p1,p2,p3;
    p1=head;
    p2=head;
    while(p2-&amp;gt;next!=NULL)
    {
        p3=p2-&amp;gt;next;
        p2-&amp;gt;next=p1;
        p1=p2;
        p2=p3;
    }
    p2-&amp;gt;next=p1;
    head-&amp;gt;next=NULL;
    head=p2;
    return head;
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/link/2012/07/22/link</link>
                <guid>http://tinyfisher.github.com/link/2012/07/22/link</guid>
                <pubDate>2012-07-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>二分查找C语言实现</title>
                <description>&lt;p&gt;据说90%的程序员都无法正确的写出二分搜索，试了下果然如此，需要注意的地方挺多（边界条件），所以讲递归与非递归的写法记录下来，以便于复习&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int binary_search(int array[],int n,int key)  //非递归
{
    int low=0;
    int high=n-1;
    while(low&amp;lt;=high)    //请注意=
    {
        if(array[low+(high-low)/2]==key)
        {
            return low+(high-low)/2;   //请注意 low+
        }
        else if(array[low+(high-low)/2]&amp;gt;key)
        {
            high=low+(high-low)/2 -1;    //请注意-1
        }
        else
        {
            low=low+(high-low)/2 +1 ;  //请注意+1
        }
    }
    return -1;
}
int binary_search(int array[],int low,int high,int key)  //递归 ,需要参数 low high
{
    if(low&amp;lt;=high)
    {
        if(key==array[low+(high-low)/2])
            return (low+(high-low)/2);
        else if(key&amp;gt;array[low+(high-low)/2])
            return binary_search(array,low+(high-low)/2+1,high,key);
        else
            return binary_search(array,low,low+(high-low)/2-1,key);
    }
    else
    {
        return -1;
    }
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/algorithm/2012/06/22/bin-search</link>
                <guid>http://tinyfisher.github.com/algorithm/2012/06/22/bin-search</guid>
                <pubDate>2012-06-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>归并排序C语言实现</title>
                <description>&lt;p&gt;话不多说，直接上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a,int *b)
{
    int temp=*a;
    *a=*b;
    *b=temp;
}
void merge_array(int a[],int low,int mid,int high,int result[])
{
    int i,j,k;
    i=low;
    j=mid+1;
    k=0;
    while(i&amp;lt;=mid&amp;amp;&amp;amp;j&amp;lt;=high)
    {
        if(a[i]&amp;lt;a[j])
        {
            result[k]=a[i];
            i++;
            k++;
        }
        else
        {
            result[k]=a[j];
            k++;
            j++;
        }
    }
    while(i&amp;lt;=mid)
    {
        result[k]=a[i];
        i++;
        k++;
    }
    while(j&amp;lt;=high)
    {
        result[k]=a[j];
        j++;
        k++;
    }
    for(i=0;i&amp;lt;k;i++)    //注意 需要这一步
    {
        a[low+i]=result[i];  //low+i
    }
}
void merge_sort(int a[],int low,int high,int temp[])
{
	int mid=(low+high)/2;
	if(low&amp;lt;high)
	{
		merge_sort(a,low,mid,temp);
		merge_sort(a,mid+1,high,temp);
		merge_array(a,low,mid,high,temp);
	}
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/algorithm/2012/06/03/merge-sort</link>
                <guid>http://tinyfisher.github.com/algorithm/2012/06/03/merge-sort</guid>
                <pubDate>2012-06-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>快速排序C语言实现</title>
                <description>&lt;p&gt;快速排序，经典必须掌握&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a,int *b)
{
    int temp=*a;
    *a=*b;
    *b=temp;
}
int partition (int input[],int low,int high)
{
    int position=low-1;
    int key=input[high];
    while(low&amp;lt;high)
    {
        if(input[low]&amp;lt;key)
        {
            position++;
            swap(&amp;amp;input[position],&amp;amp;input[low]);
        }
        low++;
    }
    position++;
    swap(&amp;amp;input[position],&amp;amp;input[high]);
    return position;

}
void q_sort(int a[],int low,int high)
{
    if(low &amp;lt; high)               //不是while，因为是递归调用
    {
        int p;
        p=partition(a,low,high);
        q_sort(a,low,p-1);
        q_sort(a,p+1,high);
     }
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/algorithm/2012/05/24/quick-sort</link>
                <guid>http://tinyfisher.github.com/algorithm/2012/05/24/quick-sort</guid>
                <pubDate>2012-05-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>堆排序C语言实现</title>
                <description>&lt;p&gt;堆的概念这里不再描述，这里主要实现堆排序，堆排序主要分为两步：&lt;br /&gt;1.堆化数组（最小堆）；&lt;br /&gt;2.交换首尾元素，（则最后一个元素为最小），调整前n-1个元素，使前n-1个元素仍为为最小堆，循环，直到还剩一个元素；这样排序下来，数组为倒序。&lt;br /&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a,int *b)
{
    int temp=*a;
    *a=*b;
    *b=temp;
}
void FixdownMinHeap(int a[],int index,int len)   //向下调整堆
{
    int father_index=index;
    int left_child_index=2*father_index+1;
    int right_child_index=2*father_index+2;
    int min=0;
    int min_index=0;
    while(left_child_index&amp;lt;len)   //重要  判断father_index不是叶子节点  
    {

        if(a[left_child_index]&amp;gt;a[right_child_index]&amp;amp;&amp;amp;right_child_index&amp;lt;len) //右节点存在且最小
        {
            min=a[right_child_index];
            min_index=right_child_index;
        }
        else
        {
            min=a[left_child_index];
            min_index=left_child_index;
        }

        if(a[father_index]&amp;gt;min)
        {
            swap(&amp;amp;a[father_index],&amp;amp;a[min_index]);
        }

        father_index=left_child_index;
        left_child_index=2*father_index+1;
        right_child_index=2*father_index+2;
    }
}
void createMinHeap(int a[],int n)//堆化数组
{
    int i=(n-1-1)/2; //因为n是数组长度，（n-1-1）/2表示最大父节点index
    while(i&amp;gt;=0)
    {
        FixdownMinHeap(a,i,n);
        i--;
    }
}
void MinHeapSort(int a[],int n)
{
    createMinHeap(a,n);
    int i=0;
    for(i=n-1;i&amp;gt;0;i--)
    {
        swap(&amp;amp;a[i],&amp;amp;a[0]);  //交换首尾元素
        FixdownMinHeap(a,0,i);  //调整堆
    }
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/algorithm/2012/05/15/heap-sort</link>
                <guid>http://tinyfisher.github.com/algorithm/2012/05/15/heap-sort</guid>
                <pubDate>2012-05-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>冒泡排序C语言实现</title>
                <description>&lt;p&gt;最近打算将各种常用的算法（排序，查找等）复习一遍，都是用C语言实现，代码均在codeblocks下编译通过。&lt;br /&gt;第一篇：冒泡排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void swap(int *a,int *b)
{
    int temp=*a;
    *a=*b;
    *b=temp;
}

void bubble_sort(int input[],int length)
{
    int i,j,flag=1;
    for(i=0;i&amp;lt;length&amp;amp;&amp;amp;flag;i++)
    {
        flag=0;             //若flag为0 表示这一趟没有交换，则已经排序完成，无需再扫描，即使扫描 也不会发生交换
        for(j=length-1;j&amp;gt;i;j--)
        {
            if(input[j]&amp;lt;input[j-1])
            {
                 swap(&amp;amp;input[j],&amp;amp;input[j-1]);
                 flag=1;
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://tinyfisher.github.com/algorithm/2012/05/02/bubble-sort</link>
                <guid>http://tinyfisher.github.com/algorithm/2012/05/02/bubble-sort</guid>
                <pubDate>2012-05-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>github 搭建博客</title>
                <description>&lt;h2 id='github'&gt;注册github帐号&lt;/h2&gt;

&lt;p&gt;在github上注册帐号,如果你的帐号为tinyfisher 创建tinyfisher.github.com这个项目.&lt;/p&gt;

&lt;h2 id='jekyll'&gt;安装jekyll&lt;/h2&gt;

&lt;p&gt;安装jekyll到github上, 这里我用的是 Jekyll-Bootstrap&lt;br /&gt;执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/plusjade/jekyll-bootstrap.git tinyfisher.github.com
cd tinyfisher.github.com
git remote set-url origin git@github.com:tinyfisher/tinyfisher.github.com.git
git push origin master&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='jekyll'&gt;配置jekyll&lt;/h2&gt;

&lt;p&gt;修改 &lt;code&gt;_config.yml&lt;/code&gt;文件 将着一些基础信息配置成你的个性化设置&lt;/p&gt;

&lt;h3 id='id1'&gt;配置首页&lt;/h3&gt;

&lt;p&gt;jekyllbootstrap默认的首页是&lt;code&gt;index.md&lt;/code&gt;&lt;br /&gt;但是如果需要分页效果的话需要使用的是&lt;code&gt;index.html&lt;/code&gt;, 并且修改&lt;code&gt;_config.yml&lt;/code&gt;, 添加一个配置项&lt;code&gt;paginate: 5&lt;/code&gt;&lt;br /&gt;详细的配置可以clone我的&lt;a href='https://github.com/tinyfisher/tinyfisher.github.com'&gt;博客项目&lt;/a&gt;进行查看&lt;/p&gt;

&lt;h2 id='id2'&gt;添加文章&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;_posts&lt;/code&gt;目录下新建一个&lt;code&gt;markdown(*.md)&lt;/code&gt;文件, 文件命名规范是&lt;code&gt;yyyy-mm-dd-url&lt;/code&gt;, 例如该文章的文件为&lt;code&gt;2012-05-18-github-blog-jekyll-bootstrap.md&lt;/code&gt;&lt;br /&gt;得到的访问路径却是&lt;a href=''&gt;/javascript/2012/05/18/github-blog-jekyll-bootstrap/&lt;/a&gt;其中/javascript是在markdown文件中配置的.&lt;/p&gt;

&lt;p&gt;markdown文件头需要几个配置, 以下是该文章的头配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: 在github上搭建博客
category: javascript
tags: [github, bootstrap, jekyll, javascript]
---&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个markdown必须在头部加上这段. 然后下面直接写markdown代码就行了.&lt;/p&gt;

&lt;h2 id='id3'&gt;遇到的问题&lt;/h2&gt;

&lt;h3 id='1gbk'&gt;1.打开浏览器出现GBK编码错误&lt;/h3&gt;

&lt;p&gt;打开Git Bash后运行 jekyll server在本地测试时出现一下错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Liquid error: invalid byte sequence in GBK&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个问题是在 Windows 下出现的，英文博文没问题，中文博文就会报错，原因是你所使用的控制台并不能工作 UTF-8。&lt;/p&gt;

&lt;p&gt;临时方案：在执行 jekyll 命令前，将当前控制台的代码格式转为 UTF-8: $export LC_ALL=en_US.UTF-8 $export LANG=en_US.UTF-8 $jekyll &amp;#8211;server &amp;#8211;auto&lt;/p&gt;

&lt;p&gt;永久方案：添加两对用户自定义的环境变量，&lt;code&gt;LC_ALL=en_US.UTF-8&lt;/code&gt; 和 &lt;code&gt;LANG=en_US.UTF-8&lt;/code&gt;在git安装目录&lt;code&gt;Git\etc\profile&lt;/code&gt;文件里加入以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考文献：&lt;a href='http://jekyllbootstrap.com/'&gt;3min搭建jekyll博客&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://tinyfisher.github.com/blog/2012/04/01/blog</link>
                <guid>http://tinyfisher.github.com/blog/2012/04/01/blog</guid>
                <pubDate>2012-04-01T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
